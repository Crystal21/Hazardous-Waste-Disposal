
algo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000022  00800200  000024e6  0000257a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000024e6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000068  00800222  00800222  0000259c  2**0
                  ALLOC
  3 .stab         000023f4  00000000  00000000  0000259c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000076a  00000000  00000000  00004990  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000a0  00000000  00000000  00005100  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000254b  00000000  00000000  000051a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000392  00000000  00000000  000076eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b17  00000000  00000000  00007a7d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000008c8  00000000  00000000  00008594  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007ae  00000000  00000000  00008e5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000198c  00000000  00000000  0000960a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000030  00000000  00000000  0000af96  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 f5 00 	jmp	0x1ea	; 0x1ea <__vector_1>
       8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      14:	0c 94 ac 06 	jmp	0xd58	; 0xd58 <__vector_5>
      18:	0c 94 87 06 	jmp	0xd0e	; 0xd0e <__vector_6>
      1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	12 e0       	ldi	r17, 0x02	; 2
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e6 ee       	ldi	r30, 0xE6	; 230
      fc:	f4 e2       	ldi	r31, 0x24	; 36
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a2 32       	cpi	r26, 0x22	; 34
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	12 e0       	ldi	r17, 0x02	; 2
     110:	a2 e2       	ldi	r26, 0x22	; 34
     112:	b2 e0       	ldi	r27, 0x02	; 2
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	aa 38       	cpi	r26, 0x8A	; 138
     11a:	b1 07       	cpc	r27, r17
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <main>
     122:	0c 94 71 12 	jmp	0x24e2	; 0x24e2 <_exit>

00000126 <__bad_interrupt>:
     126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <left_position_encoder_interrupt_init>:
	right_encoder_pin_config(); //right encoder pin config
}

void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli(); //Clears the global interrupt
     12a:	f8 94       	cli
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     12c:	ea e6       	ldi	r30, 0x6A	; 106
     12e:	f0 e0       	ldi	r31, 0x00	; 0
     130:	80 81       	ld	r24, Z
     132:	82 60       	ori	r24, 0x02	; 2
     134:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     136:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
     138:	78 94       	sei
}
     13a:	08 95       	ret

0000013c <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
     13c:	f8 94       	cli
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     13e:	ea e6       	ldi	r30, 0x6A	; 106
     140:	f0 e0       	ldi	r31, 0x00	; 0
     142:	80 81       	ld	r24, Z
     144:	88 60       	ori	r24, 0x08	; 8
     146:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     148:	ed 9a       	sbi	0x1d, 5	; 29
	sei();   // Enables the global interrupt
     14a:	78 94       	sei
}
     14c:	08 95       	ret

0000014e <buzzer_on>:
	PORTC = PORTC & 0xF7;	
}

void buzzer_on(){
	
	PORTC = 0x08;
     14e:	88 e0       	ldi	r24, 0x08	; 8
     150:	88 b9       	out	0x08, r24	; 8
}
     152:	08 95       	ret

00000154 <buzzer_off>:

void buzzer_off(){
	PORTC = 0x00;
     154:	18 b8       	out	0x08, r1	; 8
}
     156:	08 95       	ret

00000158 <lcd_port_config>:
void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7; 
     158:	87 b1       	in	r24, 0x07	; 7
     15a:	87 6f       	ori	r24, 0xF7	; 247
     15c:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80;
     15e:	88 b1       	in	r24, 0x08	; 8
     160:	80 78       	andi	r24, 0x80	; 128
     162:	88 b9       	out	0x08, r24	; 8
}
     164:	08 95       	ret

00000166 <adc_pin_config>:

void adc_pin_config (void)
{
	DDRF = 0x00;
     166:	10 ba       	out	0x10, r1	; 16
	PORTF = 0x00;
     168:	11 ba       	out	0x11, r1	; 17
	DDRK = 0x00;
     16a:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0x00;
     16e:	10 92 08 01 	sts	0x0108, r1
}
     172:	08 95       	ret

00000174 <adc_init>:

void adc_init()
{
	ADCSRA = 0x00;
     174:	ea e7       	ldi	r30, 0x7A	; 122
     176:	f0 e0       	ldi	r31, 0x00	; 0
     178:	10 82       	st	Z, r1
	ADCSRB = 0x00;		
     17a:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		
     17e:	80 e2       	ldi	r24, 0x20	; 32
     180:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
     184:	80 e8       	ldi	r24, 0x80	; 128
     186:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		
     188:	86 e8       	ldi	r24, 0x86	; 134
     18a:	80 83       	st	Z, r24
}
     18c:	08 95       	ret

0000018e <ADC_Conversion>:

unsigned char ADC_Conversion(unsigned char Ch)
{
	unsigned char a;
	if(Ch>7)
     18e:	88 30       	cpi	r24, 0x08	; 8
     190:	18 f0       	brcs	.+6      	; 0x198 <ADC_Conversion+0xa>
	{
		ADCSRB = 0x08;
     192:	98 e0       	ldi	r25, 0x08	; 8
     194:	90 93 7b 00 	sts	0x007B, r25
	}
	Ch = Ch & 0x07;
     198:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;
     19a:	80 62       	ori	r24, 0x20	; 32
     19c:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		
     1a0:	ea e7       	ldi	r30, 0x7A	; 122
     1a2:	f0 e0       	ldi	r31, 0x00	; 0
     1a4:	80 81       	ld	r24, Z
     1a6:	80 64       	ori	r24, 0x40	; 64
     1a8:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	
     1aa:	80 81       	ld	r24, Z
     1ac:	84 ff       	sbrs	r24, 4
     1ae:	fd cf       	rjmp	.-6      	; 0x1aa <ADC_Conversion+0x1c>
	a=ADCH;
     1b0:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; 
     1b4:	ea e7       	ldi	r30, 0x7A	; 122
     1b6:	f0 e0       	ldi	r31, 0x00	; 0
     1b8:	90 81       	ld	r25, Z
     1ba:	90 61       	ori	r25, 0x10	; 16
     1bc:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     1be:	10 92 7b 00 	sts	0x007B, r1
	return a;
     1c2:	08 95       	ret

000001c4 <color_sensor_pin_config>:
volatile unsigned long int no_ff;     // variable to store the pulse count when no_filter function is called
volatile unsigned long int RED, BLUE,GREEN;

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
     1c4:	8a b1       	in	r24, 0x0a	; 10
     1c6:	8e 6f       	ori	r24, 0xFE	; 254
     1c8:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
     1ca:	58 9a       	sbi	0x0b, 0	; 11
}
     1cc:	08 95       	ret

000001ce <port_init_color>:

void port_init_color(void)
{
	lcd_port_config();//lcd pin configuration
     1ce:	0e 94 ac 00 	call	0x158	; 0x158 <lcd_port_config>
	color_sensor_pin_config();//color sensor pin configuration
     1d2:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <color_sensor_pin_config>
}
     1d6:	08 95       	ret

000001d8 <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
     1d8:	f8 94       	cli
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
     1da:	e9 e6       	ldi	r30, 0x69	; 105
     1dc:	f0 e0       	ldi	r31, 0x00	; 0
     1de:	80 81       	ld	r24, Z
     1e0:	82 60       	ori	r24, 0x02	; 2
     1e2:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
     1e4:	e8 9a       	sbi	0x1d, 0	; 29
	sei(); // Enables the global interrupt
     1e6:	78 94       	sei
}
     1e8:	08 95       	ret

000001ea <__vector_1>:

//ISR for color sensor
ISR(INT0_vect)
{
     1ea:	1f 92       	push	r1
     1ec:	0f 92       	push	r0
     1ee:	0f b6       	in	r0, 0x3f	; 63
     1f0:	0f 92       	push	r0
     1f2:	11 24       	eor	r1, r1
     1f4:	8f 93       	push	r24
     1f6:	9f 93       	push	r25
     1f8:	af 93       	push	r26
     1fa:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     1fc:	80 91 58 02 	lds	r24, 0x0258
     200:	90 91 59 02 	lds	r25, 0x0259
     204:	a0 91 5a 02 	lds	r26, 0x025A
     208:	b0 91 5b 02 	lds	r27, 0x025B
     20c:	01 96       	adiw	r24, 0x01	; 1
     20e:	a1 1d       	adc	r26, r1
     210:	b1 1d       	adc	r27, r1
     212:	80 93 58 02 	sts	0x0258, r24
     216:	90 93 59 02 	sts	0x0259, r25
     21a:	a0 93 5a 02 	sts	0x025A, r26
     21e:	b0 93 5b 02 	sts	0x025B, r27
}
     222:	bf 91       	pop	r27
     224:	af 91       	pop	r26
     226:	9f 91       	pop	r25
     228:	8f 91       	pop	r24
     22a:	0f 90       	pop	r0
     22c:	0f be       	out	0x3f, r0	; 63
     22e:	0f 90       	pop	r0
     230:	1f 90       	pop	r1
     232:	18 95       	reti

00000234 <init_devices_color>:

void init_devices_color(void)
{
	cli(); //Clears the global interrupt
     234:	f8 94       	cli
	port_init_color();  //Initializes all the ports
     236:	0e 94 e7 00 	call	0x1ce	; 0x1ce <port_init_color>
	color_sensor_pin_interrupt_init();
     23a:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <color_sensor_pin_interrupt_init>
	sei();   // Enables the global interrupt
     23e:	78 94       	sei
}
     240:	08 95       	ret

00000242 <filter_red>:

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
     242:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
     244:	5f 98       	cbi	0x0b, 7	; 11
}
     246:	08 95       	ret

00000248 <filter_green>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
     248:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     24a:	5f 9a       	sbi	0x0b, 7	; 11
}
     24c:	08 95       	ret

0000024e <filter_blue>:

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
     24e:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     250:	5f 9a       	sbi	0x0b, 7	; 11
}
     252:	08 95       	ret

00000254 <filter_clear>:

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
     254:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 Low
     256:	5f 98       	cbi	0x0b, 7	; 11
}
     258:	08 95       	ret

0000025a <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
     25a:	5c 9a       	sbi	0x0b, 4	; 11
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
     25c:	5d 9a       	sbi	0x0b, 5	; 11
}
     25e:	08 95       	ret

00000260 <red_read>:

volatile unsigned long int red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
     260:	0f 93       	push	r16
     262:	1f 93       	push	r17
	//Red
	filter_red(); //select red filter
     264:	0e 94 21 01 	call	0x242	; 0x242 <filter_red>
	pulse=0; //reset the count to 0
     268:	10 92 58 02 	sts	0x0258, r1
     26c:	10 92 59 02 	sts	0x0259, r1
     270:	10 92 5a 02 	sts	0x025A, r1
     274:	10 92 5b 02 	sts	0x025B, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     278:	8f ef       	ldi	r24, 0xFF	; 255
     27a:	9f e7       	ldi	r25, 0x7F	; 127
     27c:	a4 e0       	ldi	r26, 0x04	; 4
     27e:	81 50       	subi	r24, 0x01	; 1
     280:	90 40       	sbci	r25, 0x00	; 0
     282:	a0 40       	sbci	r26, 0x00	; 0
     284:	e1 f7       	brne	.-8      	; 0x27e <red_read+0x1e>
     286:	00 c0       	rjmp	.+0      	; 0x288 <red_read+0x28>
     288:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
     28a:	80 91 58 02 	lds	r24, 0x0258
     28e:	90 91 59 02 	lds	r25, 0x0259
     292:	a0 91 5a 02 	lds	r26, 0x025A
     296:	b0 91 5b 02 	lds	r27, 0x025B
     29a:	80 93 72 02 	sts	0x0272, r24
     29e:	90 93 73 02 	sts	0x0273, r25
     2a2:	a0 93 74 02 	sts	0x0274, r26
     2a6:	b0 93 75 02 	sts	0x0275, r27
	return red;
     2aa:	00 91 72 02 	lds	r16, 0x0272
     2ae:	10 91 73 02 	lds	r17, 0x0273
     2b2:	20 91 74 02 	lds	r18, 0x0274
     2b6:	30 91 75 02 	lds	r19, 0x0275
}
     2ba:	60 2f       	mov	r22, r16
     2bc:	71 2f       	mov	r23, r17
     2be:	82 2f       	mov	r24, r18
     2c0:	93 2f       	mov	r25, r19
     2c2:	1f 91       	pop	r17
     2c4:	0f 91       	pop	r16
     2c6:	08 95       	ret

000002c8 <green_read>:

volatile unsigned long int green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
     2c8:	0f 93       	push	r16
     2ca:	1f 93       	push	r17
	//Green
	filter_green(); //select green filter
     2cc:	0e 94 24 01 	call	0x248	; 0x248 <filter_green>
	pulse=0; //reset the count to 0
     2d0:	10 92 58 02 	sts	0x0258, r1
     2d4:	10 92 59 02 	sts	0x0259, r1
     2d8:	10 92 5a 02 	sts	0x025A, r1
     2dc:	10 92 5b 02 	sts	0x025B, r1
     2e0:	8f ef       	ldi	r24, 0xFF	; 255
     2e2:	9f e7       	ldi	r25, 0x7F	; 127
     2e4:	a4 e0       	ldi	r26, 0x04	; 4
     2e6:	81 50       	subi	r24, 0x01	; 1
     2e8:	90 40       	sbci	r25, 0x00	; 0
     2ea:	a0 40       	sbci	r26, 0x00	; 0
     2ec:	e1 f7       	brne	.-8      	; 0x2e6 <green_read+0x1e>
     2ee:	00 c0       	rjmp	.+0      	; 0x2f0 <green_read+0x28>
     2f0:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
     2f2:	80 91 58 02 	lds	r24, 0x0258
     2f6:	90 91 59 02 	lds	r25, 0x0259
     2fa:	a0 91 5a 02 	lds	r26, 0x025A
     2fe:	b0 91 5b 02 	lds	r27, 0x025B
     302:	80 93 6a 02 	sts	0x026A, r24
     306:	90 93 6b 02 	sts	0x026B, r25
     30a:	a0 93 6c 02 	sts	0x026C, r26
     30e:	b0 93 6d 02 	sts	0x026D, r27
	return green;
     312:	00 91 6a 02 	lds	r16, 0x026A
     316:	10 91 6b 02 	lds	r17, 0x026B
     31a:	20 91 6c 02 	lds	r18, 0x026C
     31e:	30 91 6d 02 	lds	r19, 0x026D
}
     322:	60 2f       	mov	r22, r16
     324:	71 2f       	mov	r23, r17
     326:	82 2f       	mov	r24, r18
     328:	93 2f       	mov	r25, r19
     32a:	1f 91       	pop	r17
     32c:	0f 91       	pop	r16
     32e:	08 95       	ret

00000330 <blue_read>:

volatile unsigned long int blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
     330:	0f 93       	push	r16
     332:	1f 93       	push	r17
	//Blue
	filter_blue(); //select blue filter
     334:	0e 94 27 01 	call	0x24e	; 0x24e <filter_blue>
	pulse=0; //reset the count to 0
     338:	10 92 58 02 	sts	0x0258, r1
     33c:	10 92 59 02 	sts	0x0259, r1
     340:	10 92 5a 02 	sts	0x025A, r1
     344:	10 92 5b 02 	sts	0x025B, r1
     348:	8f ef       	ldi	r24, 0xFF	; 255
     34a:	9f e7       	ldi	r25, 0x7F	; 127
     34c:	a4 e0       	ldi	r26, 0x04	; 4
     34e:	81 50       	subi	r24, 0x01	; 1
     350:	90 40       	sbci	r25, 0x00	; 0
     352:	a0 40       	sbci	r26, 0x00	; 0
     354:	e1 f7       	brne	.-8      	; 0x34e <blue_read+0x1e>
     356:	00 c0       	rjmp	.+0      	; 0x358 <blue_read+0x28>
     358:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
     35a:	80 91 58 02 	lds	r24, 0x0258
     35e:	90 91 59 02 	lds	r25, 0x0259
     362:	a0 91 5a 02 	lds	r26, 0x025A
     366:	b0 91 5b 02 	lds	r27, 0x025B
     36a:	80 93 5c 02 	sts	0x025C, r24
     36e:	90 93 5d 02 	sts	0x025D, r25
     372:	a0 93 5e 02 	sts	0x025E, r26
     376:	b0 93 5f 02 	sts	0x025F, r27
	return blue;
     37a:	00 91 5c 02 	lds	r16, 0x025C
     37e:	10 91 5d 02 	lds	r17, 0x025D
     382:	20 91 5e 02 	lds	r18, 0x025E
     386:	30 91 5f 02 	lds	r19, 0x025F
}
     38a:	60 2f       	mov	r22, r16
     38c:	71 2f       	mov	r23, r17
     38e:	82 2f       	mov	r24, r18
     390:	93 2f       	mov	r25, r19
     392:	1f 91       	pop	r17
     394:	0f 91       	pop	r16
     396:	08 95       	ret

00000398 <no_filter>:
volatile unsigned long int no_filter()
{
     398:	0f 93       	push	r16
     39a:	1f 93       	push	r17
	filter_clear(); //select clear filter
     39c:	0e 94 2a 01 	call	0x254	; 0x254 <filter_clear>
	pulse=0; //reset the count to 0
     3a0:	10 92 58 02 	sts	0x0258, r1
     3a4:	10 92 59 02 	sts	0x0259, r1
     3a8:	10 92 5a 02 	sts	0x025A, r1
     3ac:	10 92 5b 02 	sts	0x025B, r1
     3b0:	8f ef       	ldi	r24, 0xFF	; 255
     3b2:	9f e7       	ldi	r25, 0x7F	; 127
     3b4:	a6 e1       	ldi	r26, 0x16	; 22
     3b6:	81 50       	subi	r24, 0x01	; 1
     3b8:	90 40       	sbci	r25, 0x00	; 0
     3ba:	a0 40       	sbci	r26, 0x00	; 0
     3bc:	e1 f7       	brne	.-8      	; 0x3b6 <no_filter+0x1e>
     3be:	00 c0       	rjmp	.+0      	; 0x3c0 <no_filter+0x28>
     3c0:	00 00       	nop
	_delay_ms(500); //capture the pulses for 100 ms or 0.1 second
	no_ff = (pulse);  //store the count in variable called blue
     3c2:	80 91 58 02 	lds	r24, 0x0258
     3c6:	90 91 59 02 	lds	r25, 0x0259
     3ca:	a0 91 5a 02 	lds	r26, 0x025A
     3ce:	b0 91 5b 02 	lds	r27, 0x025B
     3d2:	80 93 60 02 	sts	0x0260, r24
     3d6:	90 93 61 02 	sts	0x0261, r25
     3da:	a0 93 62 02 	sts	0x0262, r26
     3de:	b0 93 63 02 	sts	0x0263, r27
	return no_ff;	
     3e2:	00 91 60 02 	lds	r16, 0x0260
     3e6:	10 91 61 02 	lds	r17, 0x0261
     3ea:	20 91 62 02 	lds	r18, 0x0262
     3ee:	30 91 63 02 	lds	r19, 0x0263
}	
     3f2:	60 2f       	mov	r22, r16
     3f4:	71 2f       	mov	r23, r17
     3f6:	82 2f       	mov	r24, r18
     3f8:	93 2f       	mov	r25, r19
     3fa:	1f 91       	pop	r17
     3fc:	0f 91       	pop	r16
     3fe:	08 95       	ret

00000400 <detect_color>:
int detect_color() {
     400:	ef 92       	push	r14
     402:	ff 92       	push	r15
     404:	0f 93       	push	r16
     406:	1f 93       	push	r17
     408:	cf 93       	push	r28
     40a:	df 93       	push	r29
	//char* c;
	int detected = 0;
	RED = red_read();
     40c:	0e 94 30 01 	call	0x260	; 0x260 <red_read>
     410:	dc 01       	movw	r26, r24
     412:	cb 01       	movw	r24, r22
     414:	80 93 86 02 	sts	0x0286, r24
     418:	90 93 87 02 	sts	0x0287, r25
     41c:	a0 93 88 02 	sts	0x0288, r26
     420:	b0 93 89 02 	sts	0x0289, r27
	BLUE = blue_read();
     424:	0e 94 98 01 	call	0x330	; 0x330 <blue_read>
     428:	dc 01       	movw	r26, r24
     42a:	cb 01       	movw	r24, r22
     42c:	80 93 6e 02 	sts	0x026E, r24
     430:	90 93 6f 02 	sts	0x026F, r25
     434:	a0 93 70 02 	sts	0x0270, r26
     438:	b0 93 71 02 	sts	0x0271, r27
	GREEN = green_read();
     43c:	0e 94 64 01 	call	0x2c8	; 0x2c8 <green_read>
     440:	dc 01       	movw	r26, r24
     442:	cb 01       	movw	r24, r22
     444:	80 93 76 02 	sts	0x0276, r24
     448:	90 93 77 02 	sts	0x0277, r25
     44c:	a0 93 78 02 	sts	0x0278, r26
     450:	b0 93 79 02 	sts	0x0279, r27
	lcd_cursor(2,1);
     454:	0f 2e       	mov	r0, r31
     456:	fe eb       	ldi	r31, 0xBE	; 190
     458:	ef 2e       	mov	r14, r31
     45a:	f8 e0       	ldi	r31, 0x08	; 8
     45c:	ff 2e       	mov	r15, r31
     45e:	f0 2d       	mov	r31, r0
     460:	82 e0       	ldi	r24, 0x02	; 2
     462:	90 e0       	ldi	r25, 0x00	; 0
     464:	61 e0       	ldi	r22, 0x01	; 1
     466:	70 e0       	ldi	r23, 0x00	; 0
     468:	f7 01       	movw	r30, r14
     46a:	19 95       	eicall
	lcd_print(2,1,RED,3);
     46c:	cd e2       	ldi	r28, 0x2D	; 45
     46e:	d9 e0       	ldi	r29, 0x09	; 9
     470:	20 91 86 02 	lds	r18, 0x0286
     474:	30 91 87 02 	lds	r19, 0x0287
     478:	40 91 88 02 	lds	r20, 0x0288
     47c:	50 91 89 02 	lds	r21, 0x0289
     480:	82 e0       	ldi	r24, 0x02	; 2
     482:	90 e0       	ldi	r25, 0x00	; 0
     484:	61 e0       	ldi	r22, 0x01	; 1
     486:	70 e0       	ldi	r23, 0x00	; 0
     488:	03 e0       	ldi	r16, 0x03	; 3
     48a:	10 e0       	ldi	r17, 0x00	; 0
     48c:	fe 01       	movw	r30, r28
     48e:	19 95       	eicall
	lcd_print(2,6,BLUE,3);
     490:	20 91 6e 02 	lds	r18, 0x026E
     494:	30 91 6f 02 	lds	r19, 0x026F
     498:	40 91 70 02 	lds	r20, 0x0270
     49c:	50 91 71 02 	lds	r21, 0x0271
     4a0:	82 e0       	ldi	r24, 0x02	; 2
     4a2:	90 e0       	ldi	r25, 0x00	; 0
     4a4:	66 e0       	ldi	r22, 0x06	; 6
     4a6:	70 e0       	ldi	r23, 0x00	; 0
     4a8:	fe 01       	movw	r30, r28
     4aa:	19 95       	eicall
	lcd_print(2,10,GREEN,3);
     4ac:	20 91 76 02 	lds	r18, 0x0276
     4b0:	30 91 77 02 	lds	r19, 0x0277
     4b4:	40 91 78 02 	lds	r20, 0x0278
     4b8:	50 91 79 02 	lds	r21, 0x0279
     4bc:	82 e0       	ldi	r24, 0x02	; 2
     4be:	90 e0       	ldi	r25, 0x00	; 0
     4c0:	6a e0       	ldi	r22, 0x0A	; 10
     4c2:	70 e0       	ldi	r23, 0x00	; 0
     4c4:	fe 01       	movw	r30, r28
     4c6:	19 95       	eicall
	lcd_cursor(2,13);
     4c8:	82 e0       	ldi	r24, 0x02	; 2
     4ca:	90 e0       	ldi	r25, 0x00	; 0
     4cc:	6d e0       	ldi	r22, 0x0D	; 13
     4ce:	70 e0       	ldi	r23, 0x00	; 0
     4d0:	f7 01       	movw	r30, r14
     4d2:	19 95       	eicall
	if (RED > BLUE) {
     4d4:	40 91 86 02 	lds	r20, 0x0286
     4d8:	50 91 87 02 	lds	r21, 0x0287
     4dc:	60 91 88 02 	lds	r22, 0x0288
     4e0:	70 91 89 02 	lds	r23, 0x0289
     4e4:	80 91 6e 02 	lds	r24, 0x026E
     4e8:	90 91 6f 02 	lds	r25, 0x026F
     4ec:	a0 91 70 02 	lds	r26, 0x0270
     4f0:	b0 91 71 02 	lds	r27, 0x0271
     4f4:	84 17       	cp	r24, r20
     4f6:	95 07       	cpc	r25, r21
     4f8:	a6 07       	cpc	r26, r22
     4fa:	b7 07       	cpc	r27, r23
     4fc:	c0 f4       	brcc	.+48     	; 0x52e <detect_color+0x12e>
		if (RED > GREEN) {
     4fe:	40 91 86 02 	lds	r20, 0x0286
     502:	50 91 87 02 	lds	r21, 0x0287
     506:	60 91 88 02 	lds	r22, 0x0288
     50a:	70 91 89 02 	lds	r23, 0x0289
     50e:	80 91 76 02 	lds	r24, 0x0276
     512:	90 91 77 02 	lds	r25, 0x0277
     516:	a0 91 78 02 	lds	r26, 0x0278
     51a:	b0 91 79 02 	lds	r27, 0x0279
     51e:	84 17       	cp	r24, r20
     520:	95 07       	cpc	r25, r21
     522:	a6 07       	cpc	r26, r22
     524:	b7 07       	cpc	r27, r23
     526:	d8 f4       	brcc	.+54     	; 0x55e <detect_color+0x15e>
			//c = "R";
			detected = 1;
     528:	81 e0       	ldi	r24, 0x01	; 1
     52a:	90 e0       	ldi	r25, 0x00	; 0
     52c:	1d c0       	rjmp	.+58     	; 0x568 <detect_color+0x168>
		else {
			//c = "G";
			detected = 2;
		}
	} else {
		if (BLUE > GREEN) {
     52e:	40 91 6e 02 	lds	r20, 0x026E
     532:	50 91 6f 02 	lds	r21, 0x026F
     536:	60 91 70 02 	lds	r22, 0x0270
     53a:	70 91 71 02 	lds	r23, 0x0271
     53e:	80 91 76 02 	lds	r24, 0x0276
     542:	90 91 77 02 	lds	r25, 0x0277
     546:	a0 91 78 02 	lds	r26, 0x0278
     54a:	b0 91 79 02 	lds	r27, 0x0279
     54e:	84 17       	cp	r24, r20
     550:	95 07       	cpc	r25, r21
     552:	a6 07       	cpc	r26, r22
     554:	b7 07       	cpc	r27, r23
     556:	30 f4       	brcc	.+12     	; 0x564 <detect_color+0x164>
			//c = "B";
			detected = 3;
     558:	83 e0       	ldi	r24, 0x03	; 3
     55a:	90 e0       	ldi	r25, 0x00	; 0
     55c:	05 c0       	rjmp	.+10     	; 0x568 <detect_color+0x168>
			//c = "R";
			detected = 1;
		}
		else {
			//c = "G";
			detected = 2;
     55e:	82 e0       	ldi	r24, 0x02	; 2
     560:	90 e0       	ldi	r25, 0x00	; 0
     562:	02 c0       	rjmp	.+4      	; 0x568 <detect_color+0x168>
			//c = "B";
			detected = 3;
		}
		else {
			//c = "G";
			detected = 2;
     564:	82 e0       	ldi	r24, 0x02	; 2
     566:	90 e0       	ldi	r25, 0x00	; 0
		}
	}
	return detected;
	
}
     568:	df 91       	pop	r29
     56a:	cf 91       	pop	r28
     56c:	1f 91       	pop	r17
     56e:	0f 91       	pop	r16
     570:	ff 90       	pop	r15
     572:	ef 90       	pop	r14
     574:	08 95       	ret

00000576 <print_color>:

void print_color(int color) {
     576:	cf 93       	push	r28
     578:	df 93       	push	r29
     57a:	ec 01       	movw	r28, r24
	lcd_cursor(2,1);
     57c:	82 e0       	ldi	r24, 0x02	; 2
     57e:	90 e0       	ldi	r25, 0x00	; 0
     580:	61 e0       	ldi	r22, 0x01	; 1
     582:	70 e0       	ldi	r23, 0x00	; 0
     584:	0e 94 be 08 	call	0x117c	; 0x117c <lcd_cursor>
	if (color == 1)
     588:	c1 30       	cpi	r28, 0x01	; 1
     58a:	d1 05       	cpc	r29, r1
     58c:	29 f4       	brne	.+10     	; 0x598 <print_color+0x22>
	lcd_string("Red");
     58e:	80 e0       	ldi	r24, 0x00	; 0
     590:	92 e0       	ldi	r25, 0x02	; 2
     592:	0e 94 1a 09 	call	0x1234	; 0x1234 <lcd_string>
     596:	0c c0       	rjmp	.+24     	; 0x5b0 <print_color+0x3a>
	else if (color == 2)
     598:	c2 30       	cpi	r28, 0x02	; 2
     59a:	d1 05       	cpc	r29, r1
     59c:	29 f4       	brne	.+10     	; 0x5a8 <print_color+0x32>
	lcd_string("Green");
     59e:	84 e0       	ldi	r24, 0x04	; 4
     5a0:	92 e0       	ldi	r25, 0x02	; 2
     5a2:	0e 94 1a 09 	call	0x1234	; 0x1234 <lcd_string>
     5a6:	04 c0       	rjmp	.+8      	; 0x5b0 <print_color+0x3a>
	else
	lcd_string("Blue");
     5a8:	8a e0       	ldi	r24, 0x0A	; 10
     5aa:	92 e0       	ldi	r25, 0x02	; 2
     5ac:	0e 94 1a 09 	call	0x1234	; 0x1234 <lcd_string>
     5b0:	df 91       	pop	r29
     5b2:	cf 91       	pop	r28
     5b4:	08 95       	ret

000005b6 <motion_pin_config>:
#include <avr/interrupt.h>
#include <util/delay.h>

void motion_pin_config (void) 
{
 DDRA = DDRA | 0x0F;
     5b6:	81 b1       	in	r24, 0x01	; 1
     5b8:	8f 60       	ori	r24, 0x0F	; 15
     5ba:	81 b9       	out	0x01, r24	; 1
 PORTA = PORTA & 0xF0;
     5bc:	82 b1       	in	r24, 0x02	; 2
     5be:	80 7f       	andi	r24, 0xF0	; 240
     5c0:	82 b9       	out	0x02, r24	; 2
 DDRL = DDRL | 0x18;  
     5c2:	ea e0       	ldi	r30, 0x0A	; 10
     5c4:	f1 e0       	ldi	r31, 0x01	; 1
     5c6:	80 81       	ld	r24, Z
     5c8:	88 61       	ori	r24, 0x18	; 24
     5ca:	80 83       	st	Z, r24
 PORTL = PORTL | 0x18;
     5cc:	eb e0       	ldi	r30, 0x0B	; 11
     5ce:	f1 e0       	ldi	r31, 0x01	; 1
     5d0:	80 81       	ld	r24, Z
     5d2:	88 61       	ori	r24, 0x18	; 24
     5d4:	80 83       	st	Z, r24
}
     5d6:	08 95       	ret

000005d8 <timer5_init>:


void timer5_init()
{
	TCCR5B = 0x00;	
     5d8:	e1 e2       	ldi	r30, 0x21	; 33
     5da:	f1 e0       	ldi	r31, 0x01	; 1
     5dc:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	
     5de:	8f ef       	ldi	r24, 0xFF	; 255
     5e0:	80 93 25 01 	sts	0x0125, r24
	TCNT5L = 0x01;	
     5e4:	91 e0       	ldi	r25, 0x01	; 1
     5e6:	90 93 24 01 	sts	0x0124, r25
	OCR5AH = 0x00;	
     5ea:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	
     5ee:	80 93 28 01 	sts	0x0128, r24
	OCR5BH = 0x00;	
     5f2:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	
     5f6:	80 93 2a 01 	sts	0x012A, r24
	OCR5CH = 0x00;	
     5fa:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;	
     5fe:	80 93 2c 01 	sts	0x012C, r24
	TCCR5A = 0xA9;	
     602:	89 ea       	ldi	r24, 0xA9	; 169
     604:	80 93 20 01 	sts	0x0120, r24
	TCCR5B = 0x0B;	
     608:	8b e0       	ldi	r24, 0x0B	; 11
     60a:	80 83       	st	Z, r24
}
     60c:	08 95       	ret

0000060e <motion_set>:
void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;

 Direction &= 0x0F; 			
 PortARestore = PORTA; 			
     60e:	92 b1       	in	r25, 0x02	; 2
 PortARestore &= 0xF0; 			
     610:	90 7f       	andi	r25, 0xF0	; 240

void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;

 Direction &= 0x0F; 			
     612:	8f 70       	andi	r24, 0x0F	; 15
 PortARestore = PORTA; 			
 PortARestore &= 0xF0; 			
 PortARestore |= Direction; 	
     614:	98 2b       	or	r25, r24
 PORTA = PortARestore; 			
     616:	92 b9       	out	0x02, r25	; 2
}
     618:	08 95       	ret

0000061a <forward>:


void forward (void)
{
  motion_set(0x06);
     61a:	86 e0       	ldi	r24, 0x06	; 6
     61c:	0e 94 07 03 	call	0x60e	; 0x60e <motion_set>
}
     620:	08 95       	ret

00000622 <back>:

void back (void)
{
  motion_set(0x09);
     622:	89 e0       	ldi	r24, 0x09	; 9
     624:	0e 94 07 03 	call	0x60e	; 0x60e <motion_set>
}
     628:	08 95       	ret

0000062a <left>:

void left (void)
{
  motion_set(0x05);
     62a:	85 e0       	ldi	r24, 0x05	; 5
     62c:	0e 94 07 03 	call	0x60e	; 0x60e <motion_set>
}
     630:	08 95       	ret

00000632 <right>:

void right (void) 
{
  motion_set(0x0A);
     632:	8a e0       	ldi	r24, 0x0A	; 10
     634:	0e 94 07 03 	call	0x60e	; 0x60e <motion_set>
}
     638:	08 95       	ret

0000063a <soft_left>:

void soft_left (void) 
{
 motion_set(0x04);
     63a:	84 e0       	ldi	r24, 0x04	; 4
     63c:	0e 94 07 03 	call	0x60e	; 0x60e <motion_set>
}
     640:	08 95       	ret

00000642 <stop>:
void stop()
{
motion_set(0x00);
     642:	80 e0       	ldi	r24, 0x00	; 0
     644:	0e 94 07 03 	call	0x60e	; 0x60e <motion_set>
}
     648:	08 95       	ret

0000064a <angle_rotate>:
	back();
	linear_distance_mm(DistanceInMM);
}
//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees,int k)
{
     64a:	2f 92       	push	r2
     64c:	3f 92       	push	r3
     64e:	4f 92       	push	r4
     650:	5f 92       	push	r5
     652:	6f 92       	push	r6
     654:	7f 92       	push	r7
     656:	8f 92       	push	r8
     658:	9f 92       	push	r9
     65a:	af 92       	push	r10
     65c:	bf 92       	push	r11
     65e:	cf 92       	push	r12
     660:	df 92       	push	r13
     662:	ef 92       	push	r14
     664:	ff 92       	push	r15
     666:	1f 93       	push	r17
     668:	cf 93       	push	r28
     66a:	df 93       	push	r29
     66c:	d6 2f       	mov	r29, r22
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     66e:	bc 01       	movw	r22, r24
     670:	80 e0       	ldi	r24, 0x00	; 0
     672:	90 e0       	ldi	r25, 0x00	; 0
     674:	0e 94 48 11 	call	0x2290	; 0x2290 <__floatunsisf>
     678:	28 e4       	ldi	r18, 0x48	; 72
     67a:	31 ee       	ldi	r19, 0xE1	; 225
     67c:	42 e8       	ldi	r20, 0x82	; 130
     67e:	50 e4       	ldi	r21, 0x40	; 64
     680:	0e 94 af 10 	call	0x215e	; 0x215e <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     684:	0e 94 1c 11 	call	0x2238	; 0x2238 <__fixunssfsi>
     688:	2b 01       	movw	r4, r22
     68a:	66 24       	eor	r6, r6
     68c:	77 24       	eor	r7, r7
	ShaftCountRight = 0;
     68e:	10 92 31 02 	sts	0x0231, r1
     692:	10 92 32 02 	sts	0x0232, r1
     696:	10 92 33 02 	sts	0x0233, r1
     69a:	10 92 34 02 	sts	0x0234, r1
	ShaftCountLeft = 0;
     69e:	10 92 35 02 	sts	0x0235, r1
     6a2:	10 92 36 02 	sts	0x0236, r1
     6a6:	10 92 37 02 	sts	0x0237, r1
     6aa:	10 92 38 02 	sts	0x0238, r1

	while (1)
	{
		
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt) | ADC_Conversion(k) > 46)
     6ae:	22 24       	eor	r2, r2
     6b0:	33 24       	eor	r3, r3
     6b2:	23 94       	inc	r2
     6b4:	c1 e0       	ldi	r28, 0x01	; 1
     6b6:	10 e0       	ldi	r17, 0x00	; 0
     6b8:	c0 90 31 02 	lds	r12, 0x0231
     6bc:	d0 90 32 02 	lds	r13, 0x0232
     6c0:	e0 90 33 02 	lds	r14, 0x0233
     6c4:	f0 90 34 02 	lds	r15, 0x0234
     6c8:	80 90 35 02 	lds	r8, 0x0235
     6cc:	90 90 36 02 	lds	r9, 0x0236
     6d0:	a0 90 37 02 	lds	r10, 0x0237
     6d4:	b0 90 38 02 	lds	r11, 0x0238
     6d8:	8d 2f       	mov	r24, r29
     6da:	0e 94 c7 00 	call	0x18e	; 0x18e <ADC_Conversion>
     6de:	91 01       	movw	r18, r2
     6e0:	8f 32       	cpi	r24, 0x2F	; 47
     6e2:	10 f4       	brcc	.+4      	; 0x6e8 <angle_rotate+0x9e>
     6e4:	20 e0       	ldi	r18, 0x00	; 0
     6e6:	30 e0       	ldi	r19, 0x00	; 0
     6e8:	9c 2f       	mov	r25, r28
     6ea:	c4 14       	cp	r12, r4
     6ec:	d5 04       	cpc	r13, r5
     6ee:	e6 04       	cpc	r14, r6
     6f0:	f7 04       	cpc	r15, r7
     6f2:	08 f4       	brcc	.+2      	; 0x6f6 <angle_rotate+0xac>
     6f4:	91 2f       	mov	r25, r17
     6f6:	8c 2f       	mov	r24, r28
     6f8:	84 14       	cp	r8, r4
     6fa:	95 04       	cpc	r9, r5
     6fc:	a6 04       	cpc	r10, r6
     6fe:	b7 04       	cpc	r11, r7
     700:	08 f4       	brcc	.+2      	; 0x704 <angle_rotate+0xba>
     702:	81 2f       	mov	r24, r17
     704:	89 2b       	or	r24, r25
     706:	90 e0       	ldi	r25, 0x00	; 0
     708:	28 2b       	or	r18, r24
     70a:	39 2b       	or	r19, r25
     70c:	21 15       	cp	r18, r1
     70e:	31 05       	cpc	r19, r1
     710:	99 f2       	breq	.-90     	; 0x6b8 <angle_rotate+0x6e>
		break;
	}


	stop(); //Stop robot
     712:	0e 94 21 03 	call	0x642	; 0x642 <stop>
}
     716:	df 91       	pop	r29
     718:	cf 91       	pop	r28
     71a:	1f 91       	pop	r17
     71c:	ff 90       	pop	r15
     71e:	ef 90       	pop	r14
     720:	df 90       	pop	r13
     722:	cf 90       	pop	r12
     724:	bf 90       	pop	r11
     726:	af 90       	pop	r10
     728:	9f 90       	pop	r9
     72a:	8f 90       	pop	r8
     72c:	7f 90       	pop	r7
     72e:	6f 90       	pop	r6
     730:	5f 90       	pop	r5
     732:	4f 90       	pop	r4
     734:	3f 90       	pop	r3
     736:	2f 90       	pop	r2
     738:	08 95       	ret

0000073a <soft_right>:

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
	motion_set(0x02);
     73a:	82 e0       	ldi	r24, 0x02	; 2
     73c:	0e 94 07 03 	call	0x60e	; 0x60e <motion_set>
}
     740:	08 95       	ret

00000742 <soft_left_2>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
	motion_set(0x01);
     742:	81 e0       	ldi	r24, 0x01	; 1
     744:	0e 94 07 03 	call	0x60e	; 0x60e <motion_set>
}
     748:	08 95       	ret

0000074a <soft_right_2>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
	motion_set(0x08);
     74a:	88 e0       	ldi	r24, 0x08	; 8
     74c:	0e 94 07 03 	call	0x60e	; 0x60e <motion_set>
}
     750:	08 95       	ret

00000752 <velocity>:

void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     752:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char)right_motor;
     756:	60 93 2a 01 	sts	0x012A, r22
}
     75a:	08 95       	ret

0000075c <print_sensor>:
float error=0, P=0, I=0, D=0, PID_value=0;
float previous_error=0, previous_I=0;
int initial_motor_speed=200,left_motor_speed,right_motor_speed;

void print_sensor(char row, char coloumn,unsigned char channel)
{
     75c:	cf 93       	push	r28
     75e:	df 93       	push	r29
     760:	d8 2f       	mov	r29, r24
     762:	c6 2f       	mov	r28, r22
     764:	84 2f       	mov	r24, r20
	
	int ADC_Value = ADC_Conversion(channel);
     766:	0e 94 c7 00 	call	0x18e	; 0x18e <ADC_Conversion>
     76a:	48 2f       	mov	r20, r24
	lcd_print(row, coloumn, ADC_Value, 3);
     76c:	8d 2f       	mov	r24, r29
     76e:	90 e0       	ldi	r25, 0x00	; 0
     770:	6c 2f       	mov	r22, r28
     772:	70 e0       	ldi	r23, 0x00	; 0
     774:	50 e0       	ldi	r21, 0x00	; 0
     776:	23 e0       	ldi	r18, 0x03	; 3
     778:	30 e0       	ldi	r19, 0x00	; 0
     77a:	0e 94 2d 09 	call	0x125a	; 0x125a <lcd_print>
}
     77e:	df 91       	pop	r29
     780:	cf 91       	pop	r28
     782:	08 95       	ret

00000784 <fw_control_motor_speed>:

void fw_control_motor_speed()
{
     784:	8f 92       	push	r8
     786:	9f 92       	push	r9
     788:	af 92       	push	r10
     78a:	bf 92       	push	r11
     78c:	cf 92       	push	r12
     78e:	df 92       	push	r13
     790:	ef 92       	push	r14
     792:	ff 92       	push	r15
     794:	cf 93       	push	r28
     796:	df 93       	push	r29
	left_motor_speed = initial_motor_speed + PID_value;
     798:	60 91 14 02 	lds	r22, 0x0214
     79c:	70 91 15 02 	lds	r23, 0x0215
     7a0:	88 27       	eor	r24, r24
     7a2:	77 fd       	sbrc	r23, 7
     7a4:	80 95       	com	r24
     7a6:	98 2f       	mov	r25, r24
     7a8:	0e 94 4a 11 	call	0x2294	; 0x2294 <__floatsisf>
     7ac:	6b 01       	movw	r12, r22
     7ae:	7c 01       	movw	r14, r24
     7b0:	80 90 41 02 	lds	r8, 0x0241
     7b4:	90 90 42 02 	lds	r9, 0x0242
     7b8:	a0 90 43 02 	lds	r10, 0x0243
     7bc:	b0 90 44 02 	lds	r11, 0x0244
     7c0:	a5 01       	movw	r20, r10
     7c2:	94 01       	movw	r18, r8
     7c4:	0e 94 47 10 	call	0x208e	; 0x208e <__addsf3>
     7c8:	0e 94 17 11 	call	0x222e	; 0x222e <__fixsfsi>
     7cc:	dc 01       	movw	r26, r24
     7ce:	cb 01       	movw	r24, r22
     7d0:	ec 01       	movw	r28, r24
     7d2:	90 93 7d 02 	sts	0x027D, r25
     7d6:	80 93 7c 02 	sts	0x027C, r24
	right_motor_speed = initial_motor_speed - PID_value + 20;
     7da:	c7 01       	movw	r24, r14
     7dc:	b6 01       	movw	r22, r12
     7de:	a5 01       	movw	r20, r10
     7e0:	94 01       	movw	r18, r8
     7e2:	0e 94 46 10 	call	0x208c	; 0x208c <__subsf3>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 ea       	ldi	r20, 0xA0	; 160
     7ec:	51 e4       	ldi	r21, 0x41	; 65
     7ee:	0e 94 47 10 	call	0x208e	; 0x208e <__addsf3>
     7f2:	0e 94 17 11 	call	0x222e	; 0x222e <__fixsfsi>
     7f6:	ab 01       	movw	r20, r22
     7f8:	bc 01       	movw	r22, r24
     7fa:	ca 01       	movw	r24, r20
     7fc:	50 93 7f 02 	sts	0x027F, r21
     800:	40 93 7e 02 	sts	0x027E, r20
	if(left_motor_speed<=0)
     804:	1c 16       	cp	r1, r28
     806:	1d 06       	cpc	r1, r29
     808:	24 f0       	brlt	.+8      	; 0x812 <fw_control_motor_speed+0x8e>
	{
		left_motor_speed=0;
     80a:	10 92 7d 02 	sts	0x027D, r1
     80e:	10 92 7c 02 	sts	0x027C, r1
	}
	if (right_motor_speed<=0)
     812:	18 16       	cp	r1, r24
     814:	19 06       	cpc	r1, r25
     816:	24 f0       	brlt	.+8      	; 0x820 <fw_control_motor_speed+0x9c>
	{
		right_motor_speed=0;
     818:	10 92 7f 02 	sts	0x027F, r1
     81c:	10 92 7e 02 	sts	0x027E, r1
	}
	if(left_motor_speed>=255)
     820:	80 91 7c 02 	lds	r24, 0x027C
     824:	90 91 7d 02 	lds	r25, 0x027D
     828:	8f 3f       	cpi	r24, 0xFF	; 255
     82a:	91 05       	cpc	r25, r1
     82c:	34 f0       	brlt	.+12     	; 0x83a <fw_control_motor_speed+0xb6>
	{
		left_motor_speed=255;
     82e:	8f ef       	ldi	r24, 0xFF	; 255
     830:	90 e0       	ldi	r25, 0x00	; 0
     832:	90 93 7d 02 	sts	0x027D, r25
     836:	80 93 7c 02 	sts	0x027C, r24
	}
	if (right_motor_speed>=255)
     83a:	80 91 7e 02 	lds	r24, 0x027E
     83e:	90 91 7f 02 	lds	r25, 0x027F
     842:	8f 3f       	cpi	r24, 0xFF	; 255
     844:	91 05       	cpc	r25, r1
     846:	34 f0       	brlt	.+12     	; 0x854 <fw_control_motor_speed+0xd0>
	{
		right_motor_speed=255;
     848:	8f ef       	ldi	r24, 0xFF	; 255
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	90 93 7f 02 	sts	0x027F, r25
     850:	80 93 7e 02 	sts	0x027E, r24
	}
	forward();
     854:	0e 94 0d 03 	call	0x61a	; 0x61a <forward>
	velocity(left_motor_speed,right_motor_speed);
     858:	80 91 7c 02 	lds	r24, 0x027C
     85c:	60 91 7e 02 	lds	r22, 0x027E
     860:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
}
     864:	df 91       	pop	r29
     866:	cf 91       	pop	r28
     868:	ff 90       	pop	r15
     86a:	ef 90       	pop	r14
     86c:	df 90       	pop	r13
     86e:	cf 90       	pop	r12
     870:	bf 90       	pop	r11
     872:	af 90       	pop	r10
     874:	9f 90       	pop	r9
     876:	8f 90       	pop	r8
     878:	08 95       	ret

0000087a <bw_control_motor_speed>:
void bw_control_motor_speed()
{
     87a:	8f 92       	push	r8
     87c:	9f 92       	push	r9
     87e:	af 92       	push	r10
     880:	bf 92       	push	r11
     882:	cf 92       	push	r12
     884:	df 92       	push	r13
     886:	ef 92       	push	r14
     888:	ff 92       	push	r15
     88a:	cf 93       	push	r28
     88c:	df 93       	push	r29
	left_motor_speed = initial_motor_speed + PID_value;
     88e:	60 91 14 02 	lds	r22, 0x0214
     892:	70 91 15 02 	lds	r23, 0x0215
     896:	88 27       	eor	r24, r24
     898:	77 fd       	sbrc	r23, 7
     89a:	80 95       	com	r24
     89c:	98 2f       	mov	r25, r24
     89e:	0e 94 4a 11 	call	0x2294	; 0x2294 <__floatsisf>
     8a2:	6b 01       	movw	r12, r22
     8a4:	7c 01       	movw	r14, r24
     8a6:	80 90 41 02 	lds	r8, 0x0241
     8aa:	90 90 42 02 	lds	r9, 0x0242
     8ae:	a0 90 43 02 	lds	r10, 0x0243
     8b2:	b0 90 44 02 	lds	r11, 0x0244
     8b6:	a5 01       	movw	r20, r10
     8b8:	94 01       	movw	r18, r8
     8ba:	0e 94 47 10 	call	0x208e	; 0x208e <__addsf3>
     8be:	0e 94 17 11 	call	0x222e	; 0x222e <__fixsfsi>
     8c2:	dc 01       	movw	r26, r24
     8c4:	cb 01       	movw	r24, r22
     8c6:	ec 01       	movw	r28, r24
     8c8:	90 93 7d 02 	sts	0x027D, r25
     8cc:	80 93 7c 02 	sts	0x027C, r24
	right_motor_speed = initial_motor_speed - PID_value;
     8d0:	c7 01       	movw	r24, r14
     8d2:	b6 01       	movw	r22, r12
     8d4:	a5 01       	movw	r20, r10
     8d6:	94 01       	movw	r18, r8
     8d8:	0e 94 46 10 	call	0x208c	; 0x208c <__subsf3>
     8dc:	0e 94 17 11 	call	0x222e	; 0x222e <__fixsfsi>
     8e0:	ab 01       	movw	r20, r22
     8e2:	bc 01       	movw	r22, r24
     8e4:	ca 01       	movw	r24, r20
     8e6:	50 93 7f 02 	sts	0x027F, r21
     8ea:	40 93 7e 02 	sts	0x027E, r20
	if(left_motor_speed<=0)
     8ee:	1c 16       	cp	r1, r28
     8f0:	1d 06       	cpc	r1, r29
     8f2:	24 f0       	brlt	.+8      	; 0x8fc <bw_control_motor_speed+0x82>
	{
		left_motor_speed=0;
     8f4:	10 92 7d 02 	sts	0x027D, r1
     8f8:	10 92 7c 02 	sts	0x027C, r1
	}
	if (right_motor_speed<=0)
     8fc:	18 16       	cp	r1, r24
     8fe:	19 06       	cpc	r1, r25
     900:	24 f0       	brlt	.+8      	; 0x90a <bw_control_motor_speed+0x90>
	{
		right_motor_speed=0;
     902:	10 92 7f 02 	sts	0x027F, r1
     906:	10 92 7e 02 	sts	0x027E, r1
	}
	if(left_motor_speed>=255)
     90a:	80 91 7c 02 	lds	r24, 0x027C
     90e:	90 91 7d 02 	lds	r25, 0x027D
     912:	8f 3f       	cpi	r24, 0xFF	; 255
     914:	91 05       	cpc	r25, r1
     916:	34 f0       	brlt	.+12     	; 0x924 <bw_control_motor_speed+0xaa>
	{
		left_motor_speed=255;
     918:	8f ef       	ldi	r24, 0xFF	; 255
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	90 93 7d 02 	sts	0x027D, r25
     920:	80 93 7c 02 	sts	0x027C, r24
	}
	if (right_motor_speed>=255)
     924:	80 91 7e 02 	lds	r24, 0x027E
     928:	90 91 7f 02 	lds	r25, 0x027F
     92c:	8f 3f       	cpi	r24, 0xFF	; 255
     92e:	91 05       	cpc	r25, r1
     930:	34 f0       	brlt	.+12     	; 0x93e <bw_control_motor_speed+0xc4>
	{
		right_motor_speed=255;
     932:	8f ef       	ldi	r24, 0xFF	; 255
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	90 93 7f 02 	sts	0x027F, r25
     93a:	80 93 7e 02 	sts	0x027E, r24
	}
	back();
     93e:	0e 94 11 03 	call	0x622	; 0x622 <back>
	velocity(left_motor_speed,right_motor_speed);
     942:	80 91 7c 02 	lds	r24, 0x027C
     946:	60 91 7e 02 	lds	r22, 0x027E
     94a:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
}
     94e:	df 91       	pop	r29
     950:	cf 91       	pop	r28
     952:	ff 90       	pop	r15
     954:	ef 90       	pop	r14
     956:	df 90       	pop	r13
     958:	cf 90       	pop	r12
     95a:	bf 90       	pop	r11
     95c:	af 90       	pop	r10
     95e:	9f 90       	pop	r9
     960:	8f 90       	pop	r8
     962:	08 95       	ret

00000964 <black_line>:

void black_line()
{
	Left_white_line = ADC_Conversion(3);
     964:	83 e0       	ldi	r24, 0x03	; 3
     966:	0e 94 c7 00 	call	0x18e	; 0x18e <ADC_Conversion>
     96a:	80 93 57 02 	sts	0x0257, r24
	Center_white_line = ADC_Conversion(2);
     96e:	82 e0       	ldi	r24, 0x02	; 2
     970:	0e 94 c7 00 	call	0x18e	; 0x18e <ADC_Conversion>
     974:	80 93 56 02 	sts	0x0256, r24
	Right_white_line = ADC_Conversion(1);
     978:	81 e0       	ldi	r24, 0x01	; 1
     97a:	0e 94 c7 00 	call	0x18e	; 0x18e <ADC_Conversion>
     97e:	80 93 55 02 	sts	0x0255, r24
	print_sensor(1,1,3);	//Prints value of White Line Sensor1
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	61 e0       	ldi	r22, 0x01	; 1
     986:	43 e0       	ldi	r20, 0x03	; 3
     988:	0e 94 ae 03 	call	0x75c	; 0x75c <print_sensor>
	print_sensor(1,5,2);	//Prints Value of White Line Sensor2
     98c:	81 e0       	ldi	r24, 0x01	; 1
     98e:	65 e0       	ldi	r22, 0x05	; 5
     990:	42 e0       	ldi	r20, 0x02	; 2
     992:	0e 94 ae 03 	call	0x75c	; 0x75c <print_sensor>
	print_sensor(1,9,1);	//Prints Value of White Line Sensor3
     996:	81 e0       	ldi	r24, 0x01	; 1
     998:	69 e0       	ldi	r22, 0x09	; 9
     99a:	41 e0       	ldi	r20, 0x01	; 1
     99c:	0e 94 ae 03 	call	0x75c	; 0x75c <print_sensor>
	
	if(Left_white_line<=45 && Center_white_line<=16 && Right_white_line>46)
     9a0:	80 91 57 02 	lds	r24, 0x0257
     9a4:	8e 32       	cpi	r24, 0x2E	; 46
     9a6:	a8 f5       	brcc	.+106    	; 0xa12 <black_line+0xae>
     9a8:	90 91 56 02 	lds	r25, 0x0256
     9ac:	91 31       	cpi	r25, 0x11	; 17
     9ae:	88 f4       	brcc	.+34     	; 0x9d2 <black_line+0x6e>
     9b0:	20 91 55 02 	lds	r18, 0x0255
     9b4:	2f 32       	cpi	r18, 0x2F	; 47
     9b6:	68 f0       	brcs	.+26     	; 0x9d2 <black_line+0x6e>
	{
		error=2;
     9b8:	80 e0       	ldi	r24, 0x00	; 0
     9ba:	90 e0       	ldi	r25, 0x00	; 0
     9bc:	a0 e0       	ldi	r26, 0x00	; 0
     9be:	b0 e4       	ldi	r27, 0x40	; 64
     9c0:	80 93 51 02 	sts	0x0251, r24
     9c4:	90 93 52 02 	sts	0x0252, r25
     9c8:	a0 93 53 02 	sts	0x0253, r26
     9cc:	b0 93 54 02 	sts	0x0254, r27
     9d0:	08 95       	ret
	}
	else if(Left_white_line<=45 && Center_white_line>46 && Right_white_line>46)
     9d2:	9f 32       	cpi	r25, 0x2F	; 47
     9d4:	f0 f0       	brcs	.+60     	; 0xa12 <black_line+0xae>
     9d6:	90 91 55 02 	lds	r25, 0x0255
     9da:	9f 32       	cpi	r25, 0x2F	; 47
     9dc:	08 f4       	brcc	.+2      	; 0x9e0 <black_line+0x7c>
     9de:	77 c0       	rjmp	.+238    	; 0xace <black_line+0x16a>
	{
		error=1;
     9e0:	80 e0       	ldi	r24, 0x00	; 0
     9e2:	90 e0       	ldi	r25, 0x00	; 0
     9e4:	a0 e8       	ldi	r26, 0x80	; 128
     9e6:	bf e3       	ldi	r27, 0x3F	; 63
     9e8:	80 93 51 02 	sts	0x0251, r24
     9ec:	90 93 52 02 	sts	0x0252, r25
     9f0:	a0 93 53 02 	sts	0x0253, r26
     9f4:	b0 93 54 02 	sts	0x0254, r27
     9f8:	08 95       	ret
	}
	else if(Left_white_line<=45 && Center_white_line>46 && Right_white_line<=45)
	{
		error=0;
     9fa:	80 e0       	ldi	r24, 0x00	; 0
     9fc:	90 e0       	ldi	r25, 0x00	; 0
     9fe:	dc 01       	movw	r26, r24
     a00:	80 93 51 02 	sts	0x0251, r24
     a04:	90 93 52 02 	sts	0x0252, r25
     a08:	a0 93 53 02 	sts	0x0253, r26
     a0c:	b0 93 54 02 	sts	0x0254, r27
     a10:	08 95       	ret
	}
	else if(Left_white_line>46 && Center_white_line>46 && Right_white_line<=45)
     a12:	8f 32       	cpi	r24, 0x2F	; 47
     a14:	40 f1       	brcs	.+80     	; 0xa66 <black_line+0x102>
     a16:	90 91 56 02 	lds	r25, 0x0256
     a1a:	9f 32       	cpi	r25, 0x2F	; 47
     a1c:	88 f0       	brcs	.+34     	; 0xa40 <black_line+0xdc>
     a1e:	20 91 55 02 	lds	r18, 0x0255
     a22:	2e 32       	cpi	r18, 0x2E	; 46
     a24:	68 f4       	brcc	.+26     	; 0xa40 <black_line+0xdc>
	{
		error=-1;
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	90 e0       	ldi	r25, 0x00	; 0
     a2a:	a0 e8       	ldi	r26, 0x80	; 128
     a2c:	bf eb       	ldi	r27, 0xBF	; 191
     a2e:	80 93 51 02 	sts	0x0251, r24
     a32:	90 93 52 02 	sts	0x0252, r25
     a36:	a0 93 53 02 	sts	0x0253, r26
     a3a:	b0 93 54 02 	sts	0x0254, r27
     a3e:	08 95       	ret
	}
	else if(Left_white_line>46 && Center_white_line<=45 && Right_white_line<=45)
     a40:	9e 32       	cpi	r25, 0x2E	; 46
     a42:	88 f4       	brcc	.+34     	; 0xa66 <black_line+0x102>
     a44:	90 91 55 02 	lds	r25, 0x0255
     a48:	9e 32       	cpi	r25, 0x2E	; 46
     a4a:	68 f4       	brcc	.+26     	; 0xa66 <black_line+0x102>
	{
		error=-2;
     a4c:	80 e0       	ldi	r24, 0x00	; 0
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	a0 e0       	ldi	r26, 0x00	; 0
     a52:	b0 ec       	ldi	r27, 0xC0	; 192
     a54:	80 93 51 02 	sts	0x0251, r24
     a58:	90 93 52 02 	sts	0x0252, r25
     a5c:	a0 93 53 02 	sts	0x0253, r26
     a60:	b0 93 54 02 	sts	0x0254, r27
     a64:	08 95       	ret
	}
	else if(Left_white_line<=45 && Center_white_line<=45 && Right_white_line<=45)
     a66:	8e 32       	cpi	r24, 0x2E	; 46
     a68:	c0 f5       	brcc	.+112    	; 0xada <black_line+0x176>
     a6a:	80 91 56 02 	lds	r24, 0x0256
     a6e:	8e 32       	cpi	r24, 0x2E	; 46
     a70:	a0 f5       	brcc	.+104    	; 0xada <black_line+0x176>
     a72:	80 91 55 02 	lds	r24, 0x0255
     a76:	8e 32       	cpi	r24, 0x2E	; 46
     a78:	80 f5       	brcc	.+96     	; 0xada <black_line+0x176>
	{
		{
			if(error==-2)
     a7a:	60 91 51 02 	lds	r22, 0x0251
     a7e:	70 91 52 02 	lds	r23, 0x0252
     a82:	80 91 53 02 	lds	r24, 0x0253
     a86:	90 91 54 02 	lds	r25, 0x0254
     a8a:	20 e0       	ldi	r18, 0x00	; 0
     a8c:	30 e0       	ldi	r19, 0x00	; 0
     a8e:	40 e0       	ldi	r20, 0x00	; 0
     a90:	50 ec       	ldi	r21, 0xC0	; 192
     a92:	0e 94 ab 10 	call	0x2156	; 0x2156 <__cmpsf2>
     a96:	88 23       	and	r24, r24
     a98:	69 f4       	brne	.+26     	; 0xab4 <black_line+0x150>
			{
				error=-3;
     a9a:	80 e0       	ldi	r24, 0x00	; 0
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	a0 e4       	ldi	r26, 0x40	; 64
     aa0:	b0 ec       	ldi	r27, 0xC0	; 192
     aa2:	80 93 51 02 	sts	0x0251, r24
     aa6:	90 93 52 02 	sts	0x0252, r25
     aaa:	a0 93 53 02 	sts	0x0253, r26
     aae:	b0 93 54 02 	sts	0x0254, r27
     ab2:	08 95       	ret
			}
			else
			{
				error=3;
     ab4:	80 e0       	ldi	r24, 0x00	; 0
     ab6:	90 e0       	ldi	r25, 0x00	; 0
     ab8:	a0 e4       	ldi	r26, 0x40	; 64
     aba:	b0 e4       	ldi	r27, 0x40	; 64
     abc:	80 93 51 02 	sts	0x0251, r24
     ac0:	90 93 52 02 	sts	0x0252, r25
     ac4:	a0 93 53 02 	sts	0x0253, r26
     ac8:	b0 93 54 02 	sts	0x0254, r27
     acc:	08 95       	ret
	}
	else if(Left_white_line<=45 && Center_white_line>46 && Right_white_line>46)
	{
		error=1;
	}
	else if(Left_white_line<=45 && Center_white_line>46 && Right_white_line<=45)
     ace:	90 91 55 02 	lds	r25, 0x0255
     ad2:	9e 32       	cpi	r25, 0x2E	; 46
     ad4:	08 f0       	brcs	.+2      	; 0xad8 <black_line+0x174>
     ad6:	9d cf       	rjmp	.-198    	; 0xa12 <black_line+0xae>
     ad8:	90 cf       	rjmp	.-224    	; 0x9fa <black_line+0x96>
     ada:	08 95       	ret

00000adc <calculate_pid>:

		}
	}
}
void calculate_pid()
{
     adc:	4f 92       	push	r4
     ade:	5f 92       	push	r5
     ae0:	6f 92       	push	r6
     ae2:	7f 92       	push	r7
     ae4:	8f 92       	push	r8
     ae6:	9f 92       	push	r9
     ae8:	af 92       	push	r10
     aea:	bf 92       	push	r11
     aec:	cf 92       	push	r12
     aee:	df 92       	push	r13
     af0:	ef 92       	push	r14
     af2:	ff 92       	push	r15
     af4:	0f 93       	push	r16
     af6:	1f 93       	push	r17
     af8:	cf 93       	push	r28
     afa:	df 93       	push	r29
	P = error;
     afc:	c0 90 51 02 	lds	r12, 0x0251
     b00:	d0 90 52 02 	lds	r13, 0x0252
     b04:	e0 90 53 02 	lds	r14, 0x0253
     b08:	f0 90 54 02 	lds	r15, 0x0254
     b0c:	c0 92 4d 02 	sts	0x024D, r12
     b10:	d0 92 4e 02 	sts	0x024E, r13
     b14:	e0 92 4f 02 	sts	0x024F, r14
     b18:	f0 92 50 02 	sts	0x0250, r15
	I = I + previous_I;
     b1c:	60 91 49 02 	lds	r22, 0x0249
     b20:	70 91 4a 02 	lds	r23, 0x024A
     b24:	80 91 4b 02 	lds	r24, 0x024B
     b28:	90 91 4c 02 	lds	r25, 0x024C
     b2c:	20 91 39 02 	lds	r18, 0x0239
     b30:	30 91 3a 02 	lds	r19, 0x023A
     b34:	40 91 3b 02 	lds	r20, 0x023B
     b38:	50 91 3c 02 	lds	r21, 0x023C
     b3c:	0e 94 47 10 	call	0x208e	; 0x208e <__addsf3>
     b40:	c6 2f       	mov	r28, r22
     b42:	d7 2f       	mov	r29, r23
     b44:	18 2f       	mov	r17, r24
     b46:	09 2f       	mov	r16, r25
     b48:	86 2f       	mov	r24, r22
     b4a:	9d 2f       	mov	r25, r29
     b4c:	a1 2f       	mov	r26, r17
     b4e:	b0 2f       	mov	r27, r16
     b50:	80 93 49 02 	sts	0x0249, r24
     b54:	90 93 4a 02 	sts	0x024A, r25
     b58:	a0 93 4b 02 	sts	0x024B, r26
     b5c:	b0 93 4c 02 	sts	0x024C, r27
	D = error - previous_error;
     b60:	c7 01       	movw	r24, r14
     b62:	b6 01       	movw	r22, r12
     b64:	20 91 3d 02 	lds	r18, 0x023D
     b68:	30 91 3e 02 	lds	r19, 0x023E
     b6c:	40 91 3f 02 	lds	r20, 0x023F
     b70:	50 91 40 02 	lds	r21, 0x0240
     b74:	0e 94 46 10 	call	0x208c	; 0x208c <__subsf3>
     b78:	b6 2e       	mov	r11, r22
     b7a:	a7 2e       	mov	r10, r23
     b7c:	98 2e       	mov	r9, r24
     b7e:	89 2e       	mov	r8, r25
     b80:	86 2f       	mov	r24, r22
     b82:	9a 2d       	mov	r25, r10
     b84:	a9 2d       	mov	r26, r9
     b86:	b8 2d       	mov	r27, r8
     b88:	80 93 45 02 	sts	0x0245, r24
     b8c:	90 93 46 02 	sts	0x0246, r25
     b90:	a0 93 47 02 	sts	0x0247, r26
     b94:	b0 93 48 02 	sts	0x0248, r27
	
	PID_value = (Kp*P) + (Ki*I) + (Kd*D);
     b98:	c7 01       	movw	r24, r14
     b9a:	b6 01       	movw	r22, r12
     b9c:	20 91 1e 02 	lds	r18, 0x021E
     ba0:	30 91 1f 02 	lds	r19, 0x021F
     ba4:	40 91 20 02 	lds	r20, 0x0220
     ba8:	50 91 21 02 	lds	r21, 0x0221
     bac:	0e 94 fa 11 	call	0x23f4	; 0x23f4 <__mulsf3>
     bb0:	2b 01       	movw	r4, r22
     bb2:	3c 01       	movw	r6, r24
     bb4:	8c 2f       	mov	r24, r28
     bb6:	9d 2f       	mov	r25, r29
     bb8:	a1 2f       	mov	r26, r17
     bba:	b0 2f       	mov	r27, r16
     bbc:	bc 01       	movw	r22, r24
     bbe:	cd 01       	movw	r24, r26
     bc0:	20 91 1a 02 	lds	r18, 0x021A
     bc4:	30 91 1b 02 	lds	r19, 0x021B
     bc8:	40 91 1c 02 	lds	r20, 0x021C
     bcc:	50 91 1d 02 	lds	r21, 0x021D
     bd0:	0e 94 fa 11 	call	0x23f4	; 0x23f4 <__mulsf3>
     bd4:	9b 01       	movw	r18, r22
     bd6:	ac 01       	movw	r20, r24
     bd8:	c3 01       	movw	r24, r6
     bda:	b2 01       	movw	r22, r4
     bdc:	0e 94 47 10 	call	0x208e	; 0x208e <__addsf3>
     be0:	2b 01       	movw	r4, r22
     be2:	3c 01       	movw	r6, r24
     be4:	8b 2d       	mov	r24, r11
     be6:	9a 2d       	mov	r25, r10
     be8:	a9 2d       	mov	r26, r9
     bea:	b8 2d       	mov	r27, r8
     bec:	bc 01       	movw	r22, r24
     bee:	cd 01       	movw	r24, r26
     bf0:	20 91 16 02 	lds	r18, 0x0216
     bf4:	30 91 17 02 	lds	r19, 0x0217
     bf8:	40 91 18 02 	lds	r20, 0x0218
     bfc:	50 91 19 02 	lds	r21, 0x0219
     c00:	0e 94 fa 11 	call	0x23f4	; 0x23f4 <__mulsf3>
     c04:	9b 01       	movw	r18, r22
     c06:	ac 01       	movw	r20, r24
     c08:	c3 01       	movw	r24, r6
     c0a:	b2 01       	movw	r22, r4
     c0c:	0e 94 47 10 	call	0x208e	; 0x208e <__addsf3>
     c10:	dc 01       	movw	r26, r24
     c12:	cb 01       	movw	r24, r22
     c14:	80 93 41 02 	sts	0x0241, r24
     c18:	90 93 42 02 	sts	0x0242, r25
     c1c:	a0 93 43 02 	sts	0x0243, r26
     c20:	b0 93 44 02 	sts	0x0244, r27
	
	previous_I=I;
     c24:	8c 2f       	mov	r24, r28
     c26:	9d 2f       	mov	r25, r29
     c28:	a1 2f       	mov	r26, r17
     c2a:	b0 2f       	mov	r27, r16
     c2c:	80 93 39 02 	sts	0x0239, r24
     c30:	90 93 3a 02 	sts	0x023A, r25
     c34:	a0 93 3b 02 	sts	0x023B, r26
     c38:	b0 93 3c 02 	sts	0x023C, r27
	previous_error=error;
     c3c:	c0 92 3d 02 	sts	0x023D, r12
     c40:	d0 92 3e 02 	sts	0x023E, r13
     c44:	e0 92 3f 02 	sts	0x023F, r14
     c48:	f0 92 40 02 	sts	0x0240, r15
}
     c4c:	df 91       	pop	r29
     c4e:	cf 91       	pop	r28
     c50:	1f 91       	pop	r17
     c52:	0f 91       	pop	r16
     c54:	ff 90       	pop	r15
     c56:	ef 90       	pop	r14
     c58:	df 90       	pop	r13
     c5a:	cf 90       	pop	r12
     c5c:	bf 90       	pop	r11
     c5e:	af 90       	pop	r10
     c60:	9f 90       	pop	r9
     c62:	8f 90       	pop	r8
     c64:	7f 90       	pop	r7
     c66:	6f 90       	pop	r6
     c68:	5f 90       	pop	r5
     c6a:	4f 90       	pop	r4
     c6c:	08 95       	ret

00000c6e <fw_follow_black_line>:
void fw_follow_black_line() {
		while(1)
		{				
			black_line();
     c6e:	0e 94 b2 04 	call	0x964	; 0x964 <black_line>
			calculate_pid();
     c72:	0e 94 6e 05 	call	0xadc	; 0xadc <calculate_pid>
			fw_control_motor_speed();
     c76:	0e 94 c2 03 	call	0x784	; 0x784 <fw_control_motor_speed>
			if ((Left_white_line+Right_white_line+Center_white_line) >= 228) {/*		//240 added
     c7a:	20 91 57 02 	lds	r18, 0x0257
     c7e:	80 91 55 02 	lds	r24, 0x0255
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	82 0f       	add	r24, r18
     c86:	91 1d       	adc	r25, r1
     c88:	20 91 56 02 	lds	r18, 0x0256
     c8c:	82 0f       	add	r24, r18
     c8e:	91 1d       	adc	r25, r1
     c90:	84 3e       	cpi	r24, 0xE4	; 228
     c92:	91 05       	cpc	r25, r1
     c94:	64 f3       	brlt	.-40     	; 0xc6e <fw_follow_black_line>
				else if(Left_white_line<25 || Center_white_line>90 && Right_white_line>90)
				{
					soft_right_degrees(4);
					_delay_ms(50);
				}*/
			buzzer_on();
     c96:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
     c9a:	89 e9       	ldi	r24, 0x99	; 153
     c9c:	99 e5       	ldi	r25, 0x59	; 89
     c9e:	a1 e0       	ldi	r26, 0x01	; 1
     ca0:	81 50       	subi	r24, 0x01	; 1
     ca2:	90 40       	sbci	r25, 0x00	; 0
     ca4:	a0 40       	sbci	r26, 0x00	; 0
     ca6:	e1 f7       	brne	.-8      	; 0xca0 <fw_follow_black_line+0x32>
     ca8:	00 00       	nop
			_delay_ms(30);
			buzzer_off();
     caa:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
				break;
			}
		}
		stop();
     cae:	0e 94 21 03 	call	0x642	; 0x642 <stop>
		
}
     cb2:	08 95       	ret

00000cb4 <bw_follow_black_line>:
void bw_follow_black_line() {
	while(1)
	{
		
		black_line();
     cb4:	0e 94 b2 04 	call	0x964	; 0x964 <black_line>
		calculate_pid();
     cb8:	0e 94 6e 05 	call	0xadc	; 0xadc <calculate_pid>
		bw_control_motor_speed();
     cbc:	0e 94 3d 04 	call	0x87a	; 0x87a <bw_control_motor_speed>
		if ((Left_white_line+Right_white_line+Center_white_line) >= 240) {
     cc0:	20 91 57 02 	lds	r18, 0x0257
     cc4:	80 91 55 02 	lds	r24, 0x0255
     cc8:	90 e0       	ldi	r25, 0x00	; 0
     cca:	82 0f       	add	r24, r18
     ccc:	91 1d       	adc	r25, r1
     cce:	20 91 56 02 	lds	r18, 0x0256
     cd2:	82 0f       	add	r24, r18
     cd4:	91 1d       	adc	r25, r1
     cd6:	80 3f       	cpi	r24, 0xF0	; 240
     cd8:	91 05       	cpc	r25, r1
     cda:	64 f3       	brlt	.-40     	; 0xcb4 <bw_follow_black_line>
			break;
		}
	}
	stop();
     cdc:	0e 94 21 03 	call	0x642	; 0x642 <stop>
     ce0:	08 95       	ret

00000ce2 <init_devices>:
int left_dir = -1, right_dir = 1;


void init_devices()
{
	cli(); //Clears the global interrupt
     ce2:	f8 94       	cli
	port_init();  //Initializes all the ports
     ce4:	0e 94 80 06 	call	0xd00	; 0xd00 <port_init>
	left_position_encoder_interrupt_init();
     ce8:	0e 94 95 00 	call	0x12a	; 0x12a <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
     cec:	0e 94 9e 00 	call	0x13c	; 0x13c <right_position_encoder_interrupt_init>
	sei();   // Enables the global interrupt
     cf0:	78 94       	sei
}
     cf2:	08 95       	ret

00000cf4 <left_encoder_pin_config>:

void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     cf4:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     cf6:	74 9a       	sbi	0x0e, 4	; 14
}
     cf8:	08 95       	ret

00000cfa <right_encoder_pin_config>:

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     cfa:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     cfc:	75 9a       	sbi	0x0e, 5	; 14
}
     cfe:	08 95       	ret

00000d00 <port_init>:

//Function to initialize ports
void port_init()
{
	motion_pin_config(); //robot motion pins config
     d00:	0e 94 db 02 	call	0x5b6	; 0x5b6 <motion_pin_config>
	left_encoder_pin_config(); //left encoder pin config
     d04:	0e 94 7a 06 	call	0xcf4	; 0xcf4 <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
     d08:	0e 94 7d 06 	call	0xcfa	; 0xcfa <right_encoder_pin_config>
}
     d0c:	08 95       	ret

00000d0e <__vector_6>:
	sei();   // Enables the global interrupt
}

//ISR for right position encoder
ISR(INT5_vect)
{
     d0e:	1f 92       	push	r1
     d10:	0f 92       	push	r0
     d12:	0f b6       	in	r0, 0x3f	; 63
     d14:	0f 92       	push	r0
     d16:	11 24       	eor	r1, r1
     d18:	8f 93       	push	r24
     d1a:	9f 93       	push	r25
     d1c:	af 93       	push	r26
     d1e:	bf 93       	push	r27
	ShaftCountRight++;  //increment right shaft position count
     d20:	80 91 31 02 	lds	r24, 0x0231
     d24:	90 91 32 02 	lds	r25, 0x0232
     d28:	a0 91 33 02 	lds	r26, 0x0233
     d2c:	b0 91 34 02 	lds	r27, 0x0234
     d30:	01 96       	adiw	r24, 0x01	; 1
     d32:	a1 1d       	adc	r26, r1
     d34:	b1 1d       	adc	r27, r1
     d36:	80 93 31 02 	sts	0x0231, r24
     d3a:	90 93 32 02 	sts	0x0232, r25
     d3e:	a0 93 33 02 	sts	0x0233, r26
     d42:	b0 93 34 02 	sts	0x0234, r27
}
     d46:	bf 91       	pop	r27
     d48:	af 91       	pop	r26
     d4a:	9f 91       	pop	r25
     d4c:	8f 91       	pop	r24
     d4e:	0f 90       	pop	r0
     d50:	0f be       	out	0x3f, r0	; 63
     d52:	0f 90       	pop	r0
     d54:	1f 90       	pop	r1
     d56:	18 95       	reti

00000d58 <__vector_5>:


//ISR for left position encoder
ISR(INT4_vect)
{
     d58:	1f 92       	push	r1
     d5a:	0f 92       	push	r0
     d5c:	0f b6       	in	r0, 0x3f	; 63
     d5e:	0f 92       	push	r0
     d60:	11 24       	eor	r1, r1
     d62:	8f 93       	push	r24
     d64:	9f 93       	push	r25
     d66:	af 93       	push	r26
     d68:	bf 93       	push	r27
	ShaftCountLeft++;  //increment left shaft position count
     d6a:	80 91 35 02 	lds	r24, 0x0235
     d6e:	90 91 36 02 	lds	r25, 0x0236
     d72:	a0 91 37 02 	lds	r26, 0x0237
     d76:	b0 91 38 02 	lds	r27, 0x0238
     d7a:	01 96       	adiw	r24, 0x01	; 1
     d7c:	a1 1d       	adc	r26, r1
     d7e:	b1 1d       	adc	r27, r1
     d80:	80 93 35 02 	sts	0x0235, r24
     d84:	90 93 36 02 	sts	0x0236, r25
     d88:	a0 93 37 02 	sts	0x0237, r26
     d8c:	b0 93 38 02 	sts	0x0238, r27
}
     d90:	bf 91       	pop	r27
     d92:	af 91       	pop	r26
     d94:	9f 91       	pop	r25
     d96:	8f 91       	pop	r24
     d98:	0f 90       	pop	r0
     d9a:	0f be       	out	0x3f, r0	; 63
     d9c:	0f 90       	pop	r0
     d9e:	1f 90       	pop	r1
     da0:	18 95       	reti

00000da2 <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
     da2:	bc 01       	movw	r22, r24
     da4:	80 e0       	ldi	r24, 0x00	; 0
     da6:	90 e0       	ldi	r25, 0x00	; 0
     da8:	0e 94 48 11 	call	0x2290	; 0x2290 <__floatunsisf>
     dac:	25 ee       	ldi	r18, 0xE5	; 229
     dae:	30 ed       	ldi	r19, 0xD0	; 208
     db0:	4a ea       	ldi	r20, 0xAA	; 170
     db2:	50 e4       	ldi	r21, 0x40	; 64
     db4:	0e 94 af 10 	call	0x215e	; 0x215e <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     db8:	0e 94 1c 11 	call	0x2238	; 0x2238 <__fixunssfsi>
     dbc:	46 2f       	mov	r20, r22
     dbe:	57 2f       	mov	r21, r23
     dc0:	68 2f       	mov	r22, r24
     dc2:	79 2f       	mov	r23, r25
	
	ShaftCountRight = 0;
     dc4:	10 92 31 02 	sts	0x0231, r1
     dc8:	10 92 32 02 	sts	0x0232, r1
     dcc:	10 92 33 02 	sts	0x0233, r1
     dd0:	10 92 34 02 	sts	0x0234, r1
	while(1)
	{
		if(ShaftCountRight > ReqdShaftCountInt)
     dd4:	80 91 31 02 	lds	r24, 0x0231
     dd8:	90 91 32 02 	lds	r25, 0x0232
     ddc:	a0 91 33 02 	lds	r26, 0x0233
     de0:	b0 91 34 02 	lds	r27, 0x0234
     de4:	48 17       	cp	r20, r24
     de6:	59 07       	cpc	r21, r25
     de8:	6a 07       	cpc	r22, r26
     dea:	7b 07       	cpc	r23, r27
     dec:	98 f7       	brcc	.-26     	; 0xdd4 <linear_distance_mm+0x32>
		{
			break;
		}
	}
	stop(); //Stop robot
     dee:	0e 94 21 03 	call	0x642	; 0x642 <stop>
}
     df2:	08 95       	ret

00000df4 <forward_mm>:
	}
	stop();
}

void forward_mm(unsigned int DistanceInMM)
{
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	ec 01       	movw	r28, r24
	forward();
     dfa:	0e 94 0d 03 	call	0x61a	; 0x61a <forward>
	linear_distance_mm(DistanceInMM);
     dfe:	ce 01       	movw	r24, r28
     e00:	0e 94 d1 06 	call	0xda2	; 0xda2 <linear_distance_mm>
}
     e04:	df 91       	pop	r29
     e06:	cf 91       	pop	r28
     e08:	08 95       	ret

00000e0a <right_angle>:
	stop(); //Stop robot
}

void right_angle()
{
	forward_mm(20);
     e0a:	84 e1       	ldi	r24, 0x14	; 20
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
	right();
     e12:	0e 94 19 03 	call	0x632	; 0x632 <right>
	angle_rotate(90);
     e16:	8a e5       	ldi	r24, 0x5A	; 90
     e18:	90 e0       	ldi	r25, 0x00	; 0
     e1a:	0e 94 25 03 	call	0x64a	; 0x64a <angle_rotate>
	while(Left_white_line > 20)
     e1e:	80 91 57 02 	lds	r24, 0x0257
     e22:	85 31       	cpi	r24, 0x15	; 21
     e24:	58 f0       	brcs	.+22     	; 0xe3c <right_angle+0x32>
	{
		left();
     e26:	0e 94 15 03 	call	0x62a	; 0x62a <left>
     e2a:	8f ef       	ldi	r24, 0xFF	; 255
     e2c:	9f e3       	ldi	r25, 0x3F	; 63
     e2e:	a2 e0       	ldi	r26, 0x02	; 2
     e30:	81 50       	subi	r24, 0x01	; 1
     e32:	90 40       	sbci	r25, 0x00	; 0
     e34:	a0 40       	sbci	r26, 0x00	; 0
     e36:	e1 f7       	brne	.-8      	; 0xe30 <right_angle+0x26>
     e38:	00 c0       	rjmp	.+0      	; 0xe3a <right_angle+0x30>
     e3a:	00 00       	nop
		_delay_ms(50);
		break;
	}
	stop();
     e3c:	0e 94 21 03 	call	0x642	; 0x642 <stop>
}
     e40:	08 95       	ret

00000e42 <left_angle>:

void left_angle()
{
	left();
     e42:	0e 94 15 03 	call	0x62a	; 0x62a <left>
	angle_rotate(88);
     e46:	88 e5       	ldi	r24, 0x58	; 88
     e48:	90 e0       	ldi	r25, 0x00	; 0
     e4a:	0e 94 25 03 	call	0x64a	; 0x64a <angle_rotate>
	while(Right_white_line > 30)
     e4e:	80 91 55 02 	lds	r24, 0x0255
     e52:	8f 31       	cpi	r24, 0x1F	; 31
     e54:	58 f0       	brcs	.+22     	; 0xe6c <left_angle+0x2a>
	{
		right();
     e56:	0e 94 19 03 	call	0x632	; 0x632 <right>
     e5a:	8f ef       	ldi	r24, 0xFF	; 255
     e5c:	9f e3       	ldi	r25, 0x3F	; 63
     e5e:	a2 e0       	ldi	r26, 0x02	; 2
     e60:	81 50       	subi	r24, 0x01	; 1
     e62:	90 40       	sbci	r25, 0x00	; 0
     e64:	a0 40       	sbci	r26, 0x00	; 0
     e66:	e1 f7       	brne	.-8      	; 0xe60 <left_angle+0x1e>
     e68:	00 c0       	rjmp	.+0      	; 0xe6a <left_angle+0x28>
     e6a:	00 00       	nop
		_delay_ms(50);
		break;
	}
	stop();
     e6c:	0e 94 21 03 	call	0x642	; 0x642 <stop>
}
     e70:	08 95       	ret

00000e72 <backward_mm>:
{
	forward();
	linear_distance_mm(DistanceInMM);
}

void backward_mm(unsigned int DistanceInMM) {
     e72:	cf 93       	push	r28
     e74:	df 93       	push	r29
     e76:	ec 01       	movw	r28, r24
	back();
     e78:	0e 94 11 03 	call	0x622	; 0x622 <back>
	linear_distance_mm(DistanceInMM);
     e7c:	ce 01       	movw	r24, r28
     e7e:	0e 94 d1 06 	call	0xda2	; 0xda2 <linear_distance_mm>
}
     e82:	df 91       	pop	r29
     e84:	cf 91       	pop	r28
     e86:	08 95       	ret

00000e88 <flag_angle_rotate>:

	stop(); //Stop robot
}

void flag_angle_rotate(unsigned int Degrees)
{
     e88:	0f 93       	push	r16
     e8a:	1f 93       	push	r17
     e8c:	cf 93       	push	r28
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     e8e:	bc 01       	movw	r22, r24
     e90:	80 e0       	ldi	r24, 0x00	; 0
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	0e 94 48 11 	call	0x2290	; 0x2290 <__floatunsisf>
     e98:	28 e4       	ldi	r18, 0x48	; 72
     e9a:	31 ee       	ldi	r19, 0xE1	; 225
     e9c:	42 e8       	ldi	r20, 0x82	; 130
     e9e:	50 e4       	ldi	r21, 0x40	; 64
     ea0:	0e 94 af 10 	call	0x215e	; 0x215e <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     ea4:	0e 94 1c 11 	call	0x2238	; 0x2238 <__fixunssfsi>
     ea8:	dc 01       	movw	r26, r24
     eaa:	cb 01       	movw	r24, r22
     eac:	a0 e0       	ldi	r26, 0x00	; 0
     eae:	b0 e0       	ldi	r27, 0x00	; 0
	ShaftCountRight = 0;
     eb0:	10 92 31 02 	sts	0x0231, r1
     eb4:	10 92 32 02 	sts	0x0232, r1
     eb8:	10 92 33 02 	sts	0x0233, r1
     ebc:	10 92 34 02 	sts	0x0234, r1
	ShaftCountLeft = 0;
     ec0:	10 92 35 02 	sts	0x0235, r1
     ec4:	10 92 36 02 	sts	0x0236, r1
     ec8:	10 92 37 02 	sts	0x0237, r1
     ecc:	10 92 38 02 	sts	0x0238, r1

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     ed0:	f1 e0       	ldi	r31, 0x01	; 1
     ed2:	c0 e0       	ldi	r28, 0x00	; 0
     ed4:	40 91 31 02 	lds	r20, 0x0231
     ed8:	50 91 32 02 	lds	r21, 0x0232
     edc:	60 91 33 02 	lds	r22, 0x0233
     ee0:	70 91 34 02 	lds	r23, 0x0234
     ee4:	00 91 35 02 	lds	r16, 0x0235
     ee8:	10 91 36 02 	lds	r17, 0x0236
     eec:	20 91 37 02 	lds	r18, 0x0237
     ef0:	30 91 38 02 	lds	r19, 0x0238
     ef4:	ef 2f       	mov	r30, r31
     ef6:	48 17       	cp	r20, r24
     ef8:	59 07       	cpc	r21, r25
     efa:	6a 07       	cpc	r22, r26
     efc:	7b 07       	cpc	r23, r27
     efe:	08 f4       	brcc	.+2      	; 0xf02 <flag_angle_rotate+0x7a>
     f00:	ec 2f       	mov	r30, r28
     f02:	ee 23       	and	r30, r30
     f04:	49 f4       	brne	.+18     	; 0xf18 <flag_angle_rotate+0x90>
     f06:	4f 2f       	mov	r20, r31
     f08:	08 17       	cp	r16, r24
     f0a:	19 07       	cpc	r17, r25
     f0c:	2a 07       	cpc	r18, r26
     f0e:	3b 07       	cpc	r19, r27
     f10:	08 f4       	brcc	.+2      	; 0xf14 <flag_angle_rotate+0x8c>
     f12:	4c 2f       	mov	r20, r28
     f14:	44 23       	and	r20, r20
     f16:	f1 f2       	breq	.-68     	; 0xed4 <flag_angle_rotate+0x4c>
		break;
	}


	stop(); //Stop robot
     f18:	0e 94 21 03 	call	0x642	; 0x642 <stop>
}
     f1c:	cf 91       	pop	r28
     f1e:	1f 91       	pop	r17
     f20:	0f 91       	pop	r16
     f22:	08 95       	ret

00000f24 <left_degrees>:

void left_degrees(unsigned int Degrees,int flag)
{
     f24:	0f 93       	push	r16
     f26:	1f 93       	push	r17
     f28:	cf 93       	push	r28
     f2a:	df 93       	push	r29
     f2c:	8c 01       	movw	r16, r24
     f2e:	eb 01       	movw	r28, r22
	
	forward_mm(40);
     f30:	88 e2       	ldi	r24, 0x28	; 40
     f32:	90 e0       	ldi	r25, 0x00	; 0
     f34:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left(); //Turn left
     f38:	0e 94 15 03 	call	0x62a	; 0x62a <left>
     f3c:	8f ef       	ldi	r24, 0xFF	; 255
     f3e:	9f e7       	ldi	r25, 0x7F	; 127
     f40:	ad e0       	ldi	r26, 0x0D	; 13
     f42:	81 50       	subi	r24, 0x01	; 1
     f44:	90 40       	sbci	r25, 0x00	; 0
     f46:	a0 40       	sbci	r26, 0x00	; 0
     f48:	e1 f7       	brne	.-8      	; 0xf42 <left_degrees+0x1e>
     f4a:	00 c0       	rjmp	.+0      	; 0xf4c <left_degrees+0x28>
     f4c:	00 00       	nop
	_delay_ms(300);
	
	if(flag==0){
     f4e:	20 97       	sbiw	r28, 0x00	; 0
     f50:	31 f4       	brne	.+12     	; 0xf5e <left_degrees+0x3a>
		angle_rotate(Degrees,3);		//normal rotation
     f52:	c8 01       	movw	r24, r16
     f54:	63 e0       	ldi	r22, 0x03	; 3
     f56:	70 e0       	ldi	r23, 0x00	; 0
     f58:	0e 94 25 03 	call	0x64a	; 0x64a <angle_rotate>
     f5c:	03 c0       	rjmp	.+6      	; 0xf64 <left_degrees+0x40>
	}
	else{
		flag_angle_rotate(Degrees);		//rotation at flag
     f5e:	c8 01       	movw	r24, r16
     f60:	0e 94 44 07 	call	0xe88	; 0xe88 <flag_angle_rotate>
	}
	
	buzzer_on();
     f64:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
     f68:	8f ef       	ldi	r24, 0xFF	; 255
     f6a:	9f e3       	ldi	r25, 0x3F	; 63
     f6c:	a2 e0       	ldi	r26, 0x02	; 2
     f6e:	81 50       	subi	r24, 0x01	; 1
     f70:	90 40       	sbci	r25, 0x00	; 0
     f72:	a0 40       	sbci	r26, 0x00	; 0
     f74:	e1 f7       	brne	.-8      	; 0xf6e <left_degrees+0x4a>
     f76:	00 c0       	rjmp	.+0      	; 0xf78 <left_degrees+0x54>
     f78:	00 00       	nop
	_delay_ms(50);
	buzzer_off();
     f7a:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>

	//adjust_bot(Left_white_line,Center_white_line,Right_white_line);

}
     f7e:	df 91       	pop	r29
     f80:	cf 91       	pop	r28
     f82:	1f 91       	pop	r17
     f84:	0f 91       	pop	r16
     f86:	08 95       	ret

00000f88 <right_degrees>:
void right_degrees(unsigned int Degrees,int flag)
{
     f88:	0f 93       	push	r16
     f8a:	1f 93       	push	r17
     f8c:	cf 93       	push	r28
     f8e:	df 93       	push	r29
     f90:	8c 01       	movw	r16, r24
     f92:	eb 01       	movw	r28, r22
	
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	forward_mm(50);
     f94:	82 e3       	ldi	r24, 0x32	; 50
     f96:	90 e0       	ldi	r25, 0x00	; 0
     f98:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
	right(); //Turn left
     f9c:	0e 94 19 03 	call	0x632	; 0x632 <right>
     fa0:	8f ef       	ldi	r24, 0xFF	; 255
     fa2:	9f e7       	ldi	r25, 0x7F	; 127
     fa4:	ad e0       	ldi	r26, 0x0D	; 13
     fa6:	81 50       	subi	r24, 0x01	; 1
     fa8:	90 40       	sbci	r25, 0x00	; 0
     faa:	a0 40       	sbci	r26, 0x00	; 0
     fac:	e1 f7       	brne	.-8      	; 0xfa6 <right_degrees+0x1e>
     fae:	00 c0       	rjmp	.+0      	; 0xfb0 <right_degrees+0x28>
     fb0:	00 00       	nop
	_delay_ms(300);
	if(flag==0){
     fb2:	20 97       	sbiw	r28, 0x00	; 0
     fb4:	31 f4       	brne	.+12     	; 0xfc2 <right_degrees+0x3a>
		angle_rotate(Degrees,1);		//normal rotation
     fb6:	c8 01       	movw	r24, r16
     fb8:	61 e0       	ldi	r22, 0x01	; 1
     fba:	70 e0       	ldi	r23, 0x00	; 0
     fbc:	0e 94 25 03 	call	0x64a	; 0x64a <angle_rotate>
     fc0:	03 c0       	rjmp	.+6      	; 0xfc8 <right_degrees+0x40>
	}
	else{
		flag_angle_rotate(Degrees);		//rotation at flag
     fc2:	c8 01       	movw	r24, r16
     fc4:	0e 94 44 07 	call	0xe88	; 0xe88 <flag_angle_rotate>
	}
	buzzer_on();
     fc8:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
     fcc:	8f ef       	ldi	r24, 0xFF	; 255
     fce:	9f e3       	ldi	r25, 0x3F	; 63
     fd0:	a2 e0       	ldi	r26, 0x02	; 2
     fd2:	81 50       	subi	r24, 0x01	; 1
     fd4:	90 40       	sbci	r25, 0x00	; 0
     fd6:	a0 40       	sbci	r26, 0x00	; 0
     fd8:	e1 f7       	brne	.-8      	; 0xfd2 <right_degrees+0x4a>
     fda:	00 c0       	rjmp	.+0      	; 0xfdc <right_degrees+0x54>
     fdc:	00 00       	nop
	_delay_ms(50);
	buzzer_off();
     fde:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>


	//adjust_bot(Left_white_line,Center_white_line,Right_white_line);

}
     fe2:	df 91       	pop	r29
     fe4:	cf 91       	pop	r28
     fe6:	1f 91       	pop	r17
     fe8:	0f 91       	pop	r16
     fea:	08 95       	ret

00000fec <rotate_at_flag>:
void rotate_at_flag() {
	left_degrees(88,1);//105
     fec:	88 e5       	ldi	r24, 0x58	; 88
     fee:	90 e0       	ldi	r25, 0x00	; 0
     ff0:	61 e0       	ldi	r22, 0x01	; 1
     ff2:	70 e0       	ldi	r23, 0x00	; 0
     ff4:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
	forward_mm(20);//30
     ff8:	84 e1       	ldi	r24, 0x14	; 20
     ffa:	90 e0       	ldi	r25, 0x00	; 0
     ffc:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
	right_degrees(179,1);//195/178
    1000:	83 eb       	ldi	r24, 0xB3	; 179
    1002:	90 e0       	ldi	r25, 0x00	; 0
    1004:	61 e0       	ldi	r22, 0x01	; 1
    1006:	70 e0       	ldi	r23, 0x00	; 0
    1008:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
	forward_mm(5);//19
    100c:	85 e0       	ldi	r24, 0x05	; 5
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
    1014:	8f ef       	ldi	r24, 0xFF	; 255
    1016:	9f e7       	ldi	r25, 0x7F	; 127
    1018:	a6 e1       	ldi	r26, 0x16	; 22
    101a:	81 50       	subi	r24, 0x01	; 1
    101c:	90 40       	sbci	r25, 0x00	; 0
    101e:	a0 40       	sbci	r26, 0x00	; 0
    1020:	e1 f7       	brne	.-8      	; 0x101a <rotate_at_flag+0x2e>
    1022:	00 c0       	rjmp	.+0      	; 0x1024 <rotate_at_flag+0x38>
    1024:	00 00       	nop
	_delay_ms(500);
	stop();
    1026:	0e 94 21 03 	call	0x642	; 0x642 <stop>
	velocity(255,255);
    102a:	8f ef       	ldi	r24, 0xFF	; 255
    102c:	6f ef       	ldi	r22, 0xFF	; 255
    102e:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
	
}
    1032:	08 95       	ret

00001034 <soft_left_degrees>:
void soft_left_degrees(unsigned int Degrees)
{
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
    1038:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
    103a:	0e 94 1d 03 	call	0x63a	; 0x63a <soft_left>
	Degrees=Degrees*2;
	angle_rotate(Degrees,3);
    103e:	ce 01       	movw	r24, r28
    1040:	88 0f       	add	r24, r24
    1042:	99 1f       	adc	r25, r25
    1044:	63 e0       	ldi	r22, 0x03	; 3
    1046:	70 e0       	ldi	r23, 0x00	; 0
    1048:	0e 94 25 03 	call	0x64a	; 0x64a <angle_rotate>
}
    104c:	df 91       	pop	r29
    104e:	cf 91       	pop	r28
    1050:	08 95       	ret

00001052 <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
    1052:	cf 93       	push	r28
    1054:	df 93       	push	r29
    1056:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right(); //Turn soft right
    1058:	0e 94 9d 03 	call	0x73a	; 0x73a <soft_right>
	Degrees=Degrees*2;
	angle_rotate(Degrees,1);
    105c:	ce 01       	movw	r24, r28
    105e:	88 0f       	add	r24, r24
    1060:	99 1f       	adc	r25, r25
    1062:	61 e0       	ldi	r22, 0x01	; 1
    1064:	70 e0       	ldi	r23, 0x00	; 0
    1066:	0e 94 25 03 	call	0x64a	; 0x64a <angle_rotate>
}
    106a:	df 91       	pop	r29
    106c:	cf 91       	pop	r28
    106e:	08 95       	ret

00001070 <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
    1070:	cf 93       	push	r28
    1072:	df 93       	push	r29
    1074:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left_2(); //Turn reverse soft left
    1076:	0e 94 a1 03 	call	0x742	; 0x742 <soft_left_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees,3);
    107a:	ce 01       	movw	r24, r28
    107c:	88 0f       	add	r24, r24
    107e:	99 1f       	adc	r25, r25
    1080:	63 e0       	ldi	r22, 0x03	; 3
    1082:	70 e0       	ldi	r23, 0x00	; 0
    1084:	0e 94 25 03 	call	0x64a	; 0x64a <angle_rotate>
}
    1088:	df 91       	pop	r29
    108a:	cf 91       	pop	r28
    108c:	08 95       	ret

0000108e <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
    108e:	cf 93       	push	r28
    1090:	df 93       	push	r29
    1092:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right_2(); //Turn reverse soft right
    1094:	0e 94 a5 03 	call	0x74a	; 0x74a <soft_right_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees,1);
    1098:	ce 01       	movw	r24, r28
    109a:	88 0f       	add	r24, r24
    109c:	99 1f       	adc	r25, r25
    109e:	61 e0       	ldi	r22, 0x01	; 1
    10a0:	70 e0       	ldi	r23, 0x00	; 0
    10a2:	0e 94 25 03 	call	0x64a	; 0x64a <angle_rotate>
    10a6:	df 91       	pop	r29
    10a8:	cf 91       	pop	r28
    10aa:	08 95       	ret

000010ac <lcd_set_4bit>:
    10ac:	86 e6       	ldi	r24, 0x66	; 102
    10ae:	9e e0       	ldi	r25, 0x0E	; 14
    10b0:	01 97       	sbiw	r24, 0x01	; 1
    10b2:	f1 f7       	brne	.-4      	; 0x10b0 <lcd_set_4bit+0x4>
    10b4:	00 00       	nop

void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				
    10b6:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				
    10b8:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				
    10ba:	80 e3       	ldi	r24, 0x30	; 48
    10bc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				
    10be:	42 9a       	sbi	0x08, 2	; 8
    10c0:	ef ef       	ldi	r30, 0xFF	; 255
    10c2:	f7 e4       	ldi	r31, 0x47	; 71
    10c4:	31 97       	sbiw	r30, 0x01	; 1
    10c6:	f1 f7       	brne	.-4      	; 0x10c4 <lcd_set_4bit+0x18>
    10c8:	00 c0       	rjmp	.+0      	; 0x10ca <lcd_set_4bit+0x1e>
    10ca:	00 00       	nop
	_delay_ms(5);					
	cbit(lcd_port,EN);				
    10cc:	42 98       	cbi	0x08, 2	; 8
    10ce:	e6 e6       	ldi	r30, 0x66	; 102
    10d0:	fe e0       	ldi	r31, 0x0E	; 14
    10d2:	31 97       	sbiw	r30, 0x01	; 1
    10d4:	f1 f7       	brne	.-4      	; 0x10d2 <lcd_set_4bit+0x26>
    10d6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				
    10d8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				
    10da:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				
    10dc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				
    10de:	42 9a       	sbi	0x08, 2	; 8
    10e0:	ef ef       	ldi	r30, 0xFF	; 255
    10e2:	f7 e4       	ldi	r31, 0x47	; 71
    10e4:	31 97       	sbiw	r30, 0x01	; 1
    10e6:	f1 f7       	brne	.-4      	; 0x10e4 <lcd_set_4bit+0x38>
    10e8:	00 c0       	rjmp	.+0      	; 0x10ea <lcd_set_4bit+0x3e>
    10ea:	00 00       	nop
	_delay_ms(5);					
	cbit(lcd_port,EN);				
    10ec:	42 98       	cbi	0x08, 2	; 8
    10ee:	e6 e6       	ldi	r30, 0x66	; 102
    10f0:	fe e0       	ldi	r31, 0x0E	; 14
    10f2:	31 97       	sbiw	r30, 0x01	; 1
    10f4:	f1 f7       	brne	.-4      	; 0x10f2 <lcd_set_4bit+0x46>
    10f6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				
    10f8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				
    10fa:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				
    10fc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				
    10fe:	42 9a       	sbi	0x08, 2	; 8
    1100:	8f ef       	ldi	r24, 0xFF	; 255
    1102:	97 e4       	ldi	r25, 0x47	; 71
    1104:	01 97       	sbiw	r24, 0x01	; 1
    1106:	f1 f7       	brne	.-4      	; 0x1104 <lcd_set_4bit+0x58>
    1108:	00 c0       	rjmp	.+0      	; 0x110a <lcd_set_4bit+0x5e>
    110a:	00 00       	nop
	_delay_ms(5);					
	cbit(lcd_port,EN);				
    110c:	42 98       	cbi	0x08, 2	; 8
    110e:	e6 e6       	ldi	r30, 0x66	; 102
    1110:	fe e0       	ldi	r31, 0x0E	; 14
    1112:	31 97       	sbiw	r30, 0x01	; 1
    1114:	f1 f7       	brne	.-4      	; 0x1112 <lcd_set_4bit+0x66>
    1116:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				
    1118:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				
    111a:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				
    111c:	80 e2       	ldi	r24, 0x20	; 32
    111e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				
    1120:	42 9a       	sbi	0x08, 2	; 8
    1122:	8f ef       	ldi	r24, 0xFF	; 255
    1124:	97 e4       	ldi	r25, 0x47	; 71
    1126:	01 97       	sbiw	r24, 0x01	; 1
    1128:	f1 f7       	brne	.-4      	; 0x1126 <lcd_set_4bit+0x7a>
    112a:	00 c0       	rjmp	.+0      	; 0x112c <lcd_set_4bit+0x80>
    112c:	00 00       	nop
	_delay_ms(5);					
	cbit(lcd_port,EN);				
    112e:	42 98       	cbi	0x08, 2	; 8

	
}
    1130:	08 95       	ret

00001132 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
    1132:	98 b1       	in	r25, 0x08	; 8
    1134:	9f 70       	andi	r25, 0x0F	; 15
    1136:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
    1138:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
    113a:	28 2f       	mov	r18, r24
    113c:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
    113e:	92 2b       	or	r25, r18
    1140:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
    1142:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
    1144:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
    1146:	42 9a       	sbi	0x08, 2	; 8
    1148:	ef ef       	ldi	r30, 0xFF	; 255
    114a:	f7 e4       	ldi	r31, 0x47	; 71
    114c:	31 97       	sbiw	r30, 0x01	; 1
    114e:	f1 f7       	brne	.-4      	; 0x114c <lcd_wr_command+0x1a>
    1150:	00 c0       	rjmp	.+0      	; 0x1152 <lcd_wr_command+0x20>
    1152:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
    1154:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
    1156:	98 b1       	in	r25, 0x08	; 8
    1158:	9f 70       	andi	r25, 0x0F	; 15
    115a:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
    115c:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
    115e:	82 95       	swap	r24
    1160:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
    1162:	89 2b       	or	r24, r25
    1164:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
    1166:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
    1168:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
    116a:	42 9a       	sbi	0x08, 2	; 8
    116c:	8f ef       	ldi	r24, 0xFF	; 255
    116e:	97 e4       	ldi	r25, 0x47	; 71
    1170:	01 97       	sbiw	r24, 0x01	; 1
    1172:	f1 f7       	brne	.-4      	; 0x1170 <lcd_wr_command+0x3e>
    1174:	00 c0       	rjmp	.+0      	; 0x1176 <lcd_wr_command+0x44>
    1176:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
    1178:	42 98       	cbi	0x08, 2	; 8
}
    117a:	08 95       	ret

0000117c <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
    117c:	82 30       	cpi	r24, 0x02	; 2
    117e:	79 f0       	breq	.+30     	; 0x119e <lcd_cursor+0x22>
    1180:	83 30       	cpi	r24, 0x03	; 3
    1182:	18 f4       	brcc	.+6      	; 0x118a <lcd_cursor+0xe>
    1184:	81 30       	cpi	r24, 0x01	; 1
    1186:	c9 f4       	brne	.+50     	; 0x11ba <lcd_cursor+0x3e>
    1188:	05 c0       	rjmp	.+10     	; 0x1194 <lcd_cursor+0x18>
    118a:	83 30       	cpi	r24, 0x03	; 3
    118c:	69 f0       	breq	.+26     	; 0x11a8 <lcd_cursor+0x2c>
    118e:	84 30       	cpi	r24, 0x04	; 4
    1190:	a1 f4       	brne	.+40     	; 0x11ba <lcd_cursor+0x3e>
    1192:	0f c0       	rjmp	.+30     	; 0x11b2 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
    1194:	86 2f       	mov	r24, r22
    1196:	81 58       	subi	r24, 0x81	; 129
    1198:	0e 94 99 08 	call	0x1132	; 0x1132 <lcd_wr_command>
    119c:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
    119e:	86 2f       	mov	r24, r22
    11a0:	81 54       	subi	r24, 0x41	; 65
    11a2:	0e 94 99 08 	call	0x1132	; 0x1132 <lcd_wr_command>
    11a6:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
    11a8:	86 2f       	mov	r24, r22
    11aa:	8d 56       	subi	r24, 0x6D	; 109
    11ac:	0e 94 99 08 	call	0x1132	; 0x1132 <lcd_wr_command>
    11b0:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
    11b2:	86 2f       	mov	r24, r22
    11b4:	8d 52       	subi	r24, 0x2D	; 45
    11b6:	0e 94 99 08 	call	0x1132	; 0x1132 <lcd_wr_command>
    11ba:	08 95       	ret

000011bc <lcd_init>:
	
}

void lcd_init()
{
	lcd_set_4bit();
    11bc:	0e 94 56 08 	call	0x10ac	; 0x10ac <lcd_set_4bit>
    11c0:	86 e6       	ldi	r24, 0x66	; 102
    11c2:	9e e0       	ldi	r25, 0x0E	; 14
    11c4:	01 97       	sbiw	r24, 0x01	; 1
    11c6:	f1 f7       	brne	.-4      	; 0x11c4 <lcd_init+0x8>
    11c8:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			
    11ca:	88 e2       	ldi	r24, 0x28	; 40
    11cc:	0e 94 99 08 	call	0x1132	; 0x1132 <lcd_wr_command>
	lcd_wr_command(0x01);
    11d0:	81 e0       	ldi	r24, 0x01	; 1
    11d2:	0e 94 99 08 	call	0x1132	; 0x1132 <lcd_wr_command>
	lcd_wr_command(0x06);
    11d6:	86 e0       	ldi	r24, 0x06	; 6
    11d8:	0e 94 99 08 	call	0x1132	; 0x1132 <lcd_wr_command>
	lcd_wr_command(0x0E);
    11dc:	8e e0       	ldi	r24, 0x0E	; 14
    11de:	0e 94 99 08 	call	0x1132	; 0x1132 <lcd_wr_command>
	lcd_wr_command(0x80);
    11e2:	80 e8       	ldi	r24, 0x80	; 128
    11e4:	0e 94 99 08 	call	0x1132	; 0x1132 <lcd_wr_command>
		
}
    11e8:	08 95       	ret

000011ea <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
    11ea:	98 b1       	in	r25, 0x08	; 8
    11ec:	9f 70       	andi	r25, 0x0F	; 15
    11ee:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
    11f0:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
    11f2:	28 2f       	mov	r18, r24
    11f4:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
    11f6:	92 2b       	or	r25, r18
    11f8:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
    11fa:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
    11fc:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
    11fe:	42 9a       	sbi	0x08, 2	; 8
    1200:	ef ef       	ldi	r30, 0xFF	; 255
    1202:	f7 e4       	ldi	r31, 0x47	; 71
    1204:	31 97       	sbiw	r30, 0x01	; 1
    1206:	f1 f7       	brne	.-4      	; 0x1204 <lcd_wr_char+0x1a>
    1208:	00 c0       	rjmp	.+0      	; 0x120a <lcd_wr_char+0x20>
    120a:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
    120c:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
    120e:	98 b1       	in	r25, 0x08	; 8
    1210:	9f 70       	andi	r25, 0x0F	; 15
    1212:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
    1214:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
    1216:	82 95       	swap	r24
    1218:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
    121a:	89 2b       	or	r24, r25
    121c:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
    121e:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
    1220:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
    1222:	42 9a       	sbi	0x08, 2	; 8
    1224:	8f ef       	ldi	r24, 0xFF	; 255
    1226:	97 e4       	ldi	r25, 0x47	; 71
    1228:	01 97       	sbiw	r24, 0x01	; 1
    122a:	f1 f7       	brne	.-4      	; 0x1228 <lcd_wr_char+0x3e>
    122c:	00 c0       	rjmp	.+0      	; 0x122e <lcd_wr_char+0x44>
    122e:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
    1230:	42 98       	cbi	0x08, 2	; 8
}
    1232:	08 95       	ret

00001234 <lcd_string>:
}


//Function to Print String on LCD
void lcd_string(char *str)
{
    1234:	cf 93       	push	r28
    1236:	df 93       	push	r29
    1238:	ec 01       	movw	r28, r24
	while(*str != '\0')
    123a:	88 81       	ld	r24, Y
    123c:	88 23       	and	r24, r24
    123e:	31 f0       	breq	.+12     	; 0x124c <lcd_string+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
    1240:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
    1242:	0e 94 f5 08 	call	0x11ea	; 0x11ea <lcd_wr_char>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
    1246:	89 91       	ld	r24, Y+
    1248:	88 23       	and	r24, r24
    124a:	d9 f7       	brne	.-10     	; 0x1242 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
    124c:	df 91       	pop	r29
    124e:	cf 91       	pop	r28
    1250:	08 95       	ret

00001252 <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
    1252:	80 e8       	ldi	r24, 0x80	; 128
    1254:	0e 94 99 08 	call	0x1132	; 0x1132 <lcd_wr_command>
}
    1258:	08 95       	ret

0000125a <lcd_print>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
    125a:	0f 93       	push	r16
    125c:	1f 93       	push	r17
    125e:	cf 93       	push	r28
    1260:	df 93       	push	r29
    1262:	8a 01       	movw	r16, r20
    1264:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
    1266:	88 23       	and	r24, r24
    1268:	11 f0       	breq	.+4      	; 0x126e <lcd_print+0x14>
    126a:	66 23       	and	r22, r22
    126c:	19 f4       	brne	.+6      	; 0x1274 <lcd_print+0x1a>
	{
		lcd_home();
    126e:	0e 94 29 09 	call	0x1252	; 0x1252 <lcd_home>
    1272:	02 c0       	rjmp	.+4      	; 0x1278 <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
    1274:	0e 94 be 08 	call	0x117c	; 0x117c <lcd_cursor>
	}
	if(digits==5 || flag==1)
    1278:	c5 30       	cpi	r28, 0x05	; 5
    127a:	d1 05       	cpc	r29, r1
    127c:	71 f4       	brne	.+28     	; 0x129a <lcd_print+0x40>
	{
		million=value/10000+48;
    127e:	c8 01       	movw	r24, r16
    1280:	60 e1       	ldi	r22, 0x10	; 16
    1282:	77 e2       	ldi	r23, 0x27	; 39
    1284:	0e 94 5d 12 	call	0x24ba	; 0x24ba <__udivmodhi4>
    1288:	cb 01       	movw	r24, r22
    128a:	c0 96       	adiw	r24, 0x30	; 48
    128c:	90 93 67 02 	sts	0x0267, r25
    1290:	80 93 66 02 	sts	0x0266, r24
		lcd_wr_char(million);
    1294:	0e 94 f5 08 	call	0x11ea	; 0x11ea <lcd_wr_char>
    1298:	03 c0       	rjmp	.+6      	; 0x12a0 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
    129a:	c4 30       	cpi	r28, 0x04	; 4
    129c:	d1 05       	cpc	r29, r1
    129e:	b9 f4       	brne	.+46     	; 0x12ce <lcd_print+0x74>
	{
		temp = value/1000;
    12a0:	c8 01       	movw	r24, r16
    12a2:	68 ee       	ldi	r22, 0xE8	; 232
    12a4:	73 e0       	ldi	r23, 0x03	; 3
    12a6:	0e 94 5d 12 	call	0x24ba	; 0x24ba <__udivmodhi4>
    12aa:	cb 01       	movw	r24, r22
    12ac:	70 93 69 02 	sts	0x0269, r23
    12b0:	60 93 68 02 	sts	0x0268, r22
		thousand = temp%10 + 48;
    12b4:	6a e0       	ldi	r22, 0x0A	; 10
    12b6:	70 e0       	ldi	r23, 0x00	; 0
    12b8:	0e 94 5d 12 	call	0x24ba	; 0x24ba <__udivmodhi4>
    12bc:	c0 96       	adiw	r24, 0x30	; 48
    12be:	90 93 85 02 	sts	0x0285, r25
    12c2:	80 93 84 02 	sts	0x0284, r24
		lcd_wr_char(thousand);
    12c6:	0e 94 f5 08 	call	0x11ea	; 0x11ea <lcd_wr_char>
		flag=1;
    12ca:	81 e0       	ldi	r24, 0x01	; 1
    12cc:	01 c0       	rjmp	.+2      	; 0x12d0 <lcd_print+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
    12ce:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
    12d0:	c3 30       	cpi	r28, 0x03	; 3
    12d2:	d1 05       	cpc	r29, r1
    12d4:	11 f0       	breq	.+4      	; 0x12da <lcd_print+0x80>
    12d6:	81 30       	cpi	r24, 0x01	; 1
    12d8:	b1 f4       	brne	.+44     	; 0x1306 <lcd_print+0xac>
	{
		temp = value/100;
    12da:	c8 01       	movw	r24, r16
    12dc:	64 e6       	ldi	r22, 0x64	; 100
    12de:	70 e0       	ldi	r23, 0x00	; 0
    12e0:	0e 94 5d 12 	call	0x24ba	; 0x24ba <__udivmodhi4>
    12e4:	cb 01       	movw	r24, r22
    12e6:	70 93 69 02 	sts	0x0269, r23
    12ea:	60 93 68 02 	sts	0x0268, r22
		hundred = temp%10 + 48;
    12ee:	6a e0       	ldi	r22, 0x0A	; 10
    12f0:	70 e0       	ldi	r23, 0x00	; 0
    12f2:	0e 94 5d 12 	call	0x24ba	; 0x24ba <__udivmodhi4>
    12f6:	c0 96       	adiw	r24, 0x30	; 48
    12f8:	90 93 81 02 	sts	0x0281, r25
    12fc:	80 93 80 02 	sts	0x0280, r24
		lcd_wr_char(hundred);
    1300:	0e 94 f5 08 	call	0x11ea	; 0x11ea <lcd_wr_char>
		flag=1;
    1304:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
    1306:	c2 30       	cpi	r28, 0x02	; 2
    1308:	d1 05       	cpc	r29, r1
    130a:	11 f0       	breq	.+4      	; 0x1310 <lcd_print+0xb6>
    130c:	81 30       	cpi	r24, 0x01	; 1
    130e:	b1 f4       	brne	.+44     	; 0x133c <lcd_print+0xe2>
	{
		temp = value/10;
    1310:	2a e0       	ldi	r18, 0x0A	; 10
    1312:	30 e0       	ldi	r19, 0x00	; 0
    1314:	c8 01       	movw	r24, r16
    1316:	b9 01       	movw	r22, r18
    1318:	0e 94 5d 12 	call	0x24ba	; 0x24ba <__udivmodhi4>
    131c:	cb 01       	movw	r24, r22
    131e:	70 93 69 02 	sts	0x0269, r23
    1322:	60 93 68 02 	sts	0x0268, r22
		tens = temp%10 + 48;
    1326:	b9 01       	movw	r22, r18
    1328:	0e 94 5d 12 	call	0x24ba	; 0x24ba <__udivmodhi4>
    132c:	c0 96       	adiw	r24, 0x30	; 48
    132e:	90 93 7b 02 	sts	0x027B, r25
    1332:	80 93 7a 02 	sts	0x027A, r24
		lcd_wr_char(tens);
    1336:	0e 94 f5 08 	call	0x11ea	; 0x11ea <lcd_wr_char>
		flag=1;
    133a:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
    133c:	c1 30       	cpi	r28, 0x01	; 1
    133e:	d1 05       	cpc	r29, r1
    1340:	11 f0       	breq	.+4      	; 0x1346 <lcd_print+0xec>
    1342:	81 30       	cpi	r24, 0x01	; 1
    1344:	61 f4       	brne	.+24     	; 0x135e <lcd_print+0x104>
	{
		unit = value%10 + 48;
    1346:	c8 01       	movw	r24, r16
    1348:	6a e0       	ldi	r22, 0x0A	; 10
    134a:	70 e0       	ldi	r23, 0x00	; 0
    134c:	0e 94 5d 12 	call	0x24ba	; 0x24ba <__udivmodhi4>
    1350:	c0 96       	adiw	r24, 0x30	; 48
    1352:	90 93 83 02 	sts	0x0283, r25
    1356:	80 93 82 02 	sts	0x0282, r24
		lcd_wr_char(unit);
    135a:	0e 94 f5 08 	call	0x11ea	; 0x11ea <lcd_wr_char>
	}
	if(digits>5)
    135e:	c6 30       	cpi	r28, 0x06	; 6
    1360:	d1 05       	cpc	r29, r1
    1362:	1c f0       	brlt	.+6      	; 0x136a <lcd_print+0x110>
	{
		lcd_wr_char('E');
    1364:	85 e4       	ldi	r24, 0x45	; 69
    1366:	0e 94 f5 08 	call	0x11ea	; 0x11ea <lcd_wr_char>
	}
	
}
    136a:	df 91       	pop	r29
    136c:	cf 91       	pop	r28
    136e:	1f 91       	pop	r17
    1370:	0f 91       	pop	r16
    1372:	08 95       	ret

00001374 <buzzer_pin_config>:
void buzzer_pin_config(){
	
	DDRC = DDRC | 0x08;
    1374:	3b 9a       	sbi	0x07, 3	; 7
	PORTC = PORTC & 0xF7;	
    1376:	43 98       	cbi	0x08, 3	; 8
}
    1378:	08 95       	ret

0000137a <servo1_pin_config>:
unsigned char i = 0;
unsigned char grip_switch = 0x40;

void servo1_pin_config (void)
{
 DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
    137a:	25 9a       	sbi	0x04, 5	; 4
 PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
    137c:	2d 9a       	sbi	0x05, 5	; 5
}
    137e:	08 95       	ret

00001380 <servo2_pin_config>:

void servo2_pin_config (void)
{
 DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
    1380:	26 9a       	sbi	0x04, 6	; 4
 PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
    1382:	2e 9a       	sbi	0x05, 6	; 5
 DDRL  = DDRL | 0xBF;  //making PORTL 6 pin input
    1384:	ea e0       	ldi	r30, 0x0A	; 10
    1386:	f1 e0       	ldi	r31, 0x01	; 1
    1388:	80 81       	ld	r24, Z
    138a:	8f 6b       	ori	r24, 0xBF	; 191
    138c:	80 83       	st	Z, r24
 PORTL = PORTL | 0x40; //PORTL 6 internal pull-up enabled
    138e:	eb e0       	ldi	r30, 0x0B	; 11
    1390:	f1 e0       	ldi	r31, 0x01	; 1
    1392:	80 81       	ld	r24, Z
    1394:	80 64       	ori	r24, 0x40	; 64
    1396:	80 83       	st	Z, r24
}
    1398:	08 95       	ret

0000139a <timer1_init>:
//prescale:256
// WGM: 7) PWM 10bit fast, TOP=0x03FF
// actual value: 52.25Hz 
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
    139a:	e1 e8       	ldi	r30, 0x81	; 129
    139c:	f0 e0       	ldi	r31, 0x00	; 0
    139e:	10 82       	st	Z, r1
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
    13a0:	8c ef       	ldi	r24, 0xFC	; 252
    13a2:	80 93 85 00 	sts	0x0085, r24
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	80 93 84 00 	sts	0x0084, r24
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
    13ac:	93 e0       	ldi	r25, 0x03	; 3
    13ae:	90 93 89 00 	sts	0x0089, r25
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
    13b2:	8f ef       	ldi	r24, 0xFF	; 255
    13b4:	80 93 88 00 	sts	0x0088, r24
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
    13b8:	90 93 8b 00 	sts	0x008B, r25
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
    13bc:	80 93 8a 00 	sts	0x008A, r24
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
    13c0:	90 93 8d 00 	sts	0x008D, r25
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
    13c4:	80 93 8c 00 	sts	0x008C, r24
 ICR1H  = 0x03;	
    13c8:	90 93 87 00 	sts	0x0087, r25
 ICR1L  = 0xFF;
    13cc:	80 93 86 00 	sts	0x0086, r24
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
    13d0:	8b ea       	ldi	r24, 0xAB	; 171
    13d2:	80 93 80 00 	sts	0x0080, r24
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
    13d6:	10 92 82 00 	sts	0x0082, r1
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
    13da:	8c e0       	ldi	r24, 0x0C	; 12
    13dc:	80 83       	st	Z, r24
}
    13de:	08 95       	ret

000013e0 <servo_1>:

void servo_1(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
 OCR1AH = 0x00;
    13e0:	10 92 89 00 	sts	0x0089, r1
}

void servo_1(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
    13e4:	68 2f       	mov	r22, r24
    13e6:	70 e0       	ldi	r23, 0x00	; 0
    13e8:	80 e0       	ldi	r24, 0x00	; 0
    13ea:	90 e0       	ldi	r25, 0x00	; 0
    13ec:	0e 94 48 11 	call	0x2290	; 0x2290 <__floatunsisf>
    13f0:	2b e7       	ldi	r18, 0x7B	; 123
    13f2:	34 e1       	ldi	r19, 0x14	; 20
    13f4:	4e ee       	ldi	r20, 0xEE	; 238
    13f6:	5f e3       	ldi	r21, 0x3F	; 63
    13f8:	0e 94 af 10 	call	0x215e	; 0x215e <__divsf3>
    13fc:	20 e0       	ldi	r18, 0x00	; 0
    13fe:	30 e0       	ldi	r19, 0x00	; 0
    1400:	4c e0       	ldi	r20, 0x0C	; 12
    1402:	52 e4       	ldi	r21, 0x42	; 66
    1404:	0e 94 47 10 	call	0x208e	; 0x208e <__addsf3>
 OCR1AH = 0x00;
 OCR1AL = (unsigned char) PositionPanServo;
    1408:	0e 94 1c 11 	call	0x2238	; 0x2238 <__fixunssfsi>
    140c:	60 93 88 00 	sts	0x0088, r22
}
    1410:	08 95       	ret

00001412 <servo_2>:

void servo_2(unsigned char degrees)
{
 float PositionTiltServo = 0;
 PositionTiltServo = ((float)degrees / 1.86) + 35.0;
 OCR1BH = 0x00;
    1412:	10 92 8b 00 	sts	0x008B, r1
}

void servo_2(unsigned char degrees)
{
 float PositionTiltServo = 0;
 PositionTiltServo = ((float)degrees / 1.86) + 35.0;
    1416:	68 2f       	mov	r22, r24
    1418:	70 e0       	ldi	r23, 0x00	; 0
    141a:	80 e0       	ldi	r24, 0x00	; 0
    141c:	90 e0       	ldi	r25, 0x00	; 0
    141e:	0e 94 48 11 	call	0x2290	; 0x2290 <__floatunsisf>
    1422:	2b e7       	ldi	r18, 0x7B	; 123
    1424:	34 e1       	ldi	r19, 0x14	; 20
    1426:	4e ee       	ldi	r20, 0xEE	; 238
    1428:	5f e3       	ldi	r21, 0x3F	; 63
    142a:	0e 94 af 10 	call	0x215e	; 0x215e <__divsf3>
    142e:	20 e0       	ldi	r18, 0x00	; 0
    1430:	30 e0       	ldi	r19, 0x00	; 0
    1432:	4c e0       	ldi	r20, 0x0C	; 12
    1434:	52 e4       	ldi	r21, 0x42	; 66
    1436:	0e 94 47 10 	call	0x208e	; 0x208e <__addsf3>
 OCR1BH = 0x00;
 OCR1BL = (unsigned char) PositionTiltServo;
    143a:	0e 94 1c 11 	call	0x2238	; 0x2238 <__fixunssfsi>
    143e:	60 93 8a 00 	sts	0x008A, r22
}
    1442:	08 95       	ret

00001444 <servo_1_free>:
//and make them free by giving 100% duty cycle at the PWM. This function can be used to 
//reduce the power consumption of the motor if it is holding load against the gravity.

void servo_1_free (void)
{
 OCR1AH = 0x03; 
    1444:	83 e0       	ldi	r24, 0x03	; 3
    1446:	80 93 89 00 	sts	0x0089, r24
 OCR1AL = 0xFF; //Servo 1 off
    144a:	8f ef       	ldi	r24, 0xFF	; 255
    144c:	80 93 88 00 	sts	0x0088, r24
}
    1450:	08 95       	ret

00001452 <servo_2_free>:

void servo_2_free (void)
{
 OCR1BH = 0x03;
    1452:	83 e0       	ldi	r24, 0x03	; 3
    1454:	80 93 8b 00 	sts	0x008B, r24
 OCR1BL = 0xFF; //Servo 2 off
    1458:	8f ef       	ldi	r24, 0xFF	; 255
    145a:	80 93 8a 00 	sts	0x008A, r24
}
    145e:	08 95       	ret

00001460 <place_block>:

void place_block()
{
	for (i = 160; i > 84; i--)
    1460:	80 ea       	ldi	r24, 0xA0	; 160
    1462:	80 93 30 02 	sts	0x0230, r24
	{
		servo_1(i);
    1466:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <servo_1>
    146a:	82 e3       	ldi	r24, 0x32	; 50
    146c:	93 eb       	ldi	r25, 0xB3	; 179
    146e:	a2 e0       	ldi	r26, 0x02	; 2
    1470:	81 50       	subi	r24, 0x01	; 1
    1472:	90 40       	sbci	r25, 0x00	; 0
    1474:	a0 40       	sbci	r26, 0x00	; 0
    1476:	e1 f7       	brne	.-8      	; 0x1470 <place_block+0x10>
    1478:	00 c0       	rjmp	.+0      	; 0x147a <place_block+0x1a>
    147a:	00 c0       	rjmp	.+0      	; 0x147c <place_block+0x1c>
 OCR1BL = 0xFF; //Servo 2 off
}

void place_block()
{
	for (i = 160; i > 84; i--)
    147c:	80 91 30 02 	lds	r24, 0x0230
    1480:	81 50       	subi	r24, 0x01	; 1
    1482:	80 93 30 02 	sts	0x0230, r24
    1486:	85 35       	cpi	r24, 0x55	; 85
    1488:	70 f7       	brcc	.-36     	; 0x1466 <place_block+0x6>
	{
		servo_1(i);
		_delay_ms(60);
	}
	servo_2(100);
    148a:	84 e6       	ldi	r24, 0x64	; 100
    148c:	0e 94 09 0a 	call	0x1412	; 0x1412 <servo_2>
    1490:	8f ef       	ldi	r24, 0xFF	; 255
    1492:	9f e7       	ldi	r25, 0x7F	; 127
    1494:	a6 e1       	ldi	r26, 0x16	; 22
    1496:	81 50       	subi	r24, 0x01	; 1
    1498:	90 40       	sbci	r25, 0x00	; 0
    149a:	a0 40       	sbci	r26, 0x00	; 0
    149c:	e1 f7       	brne	.-8      	; 0x1496 <place_block+0x36>
    149e:	00 c0       	rjmp	.+0      	; 0x14a0 <place_block+0x40>
    14a0:	00 00       	nop
	_delay_ms(500);
	for (i = 84; i < 130; i++)
    14a2:	84 e5       	ldi	r24, 0x54	; 84
    14a4:	80 93 30 02 	sts	0x0230, r24
	{
		servo_1(i);
    14a8:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <servo_1>
    14ac:	89 e9       	ldi	r24, 0x99	; 153
    14ae:	99 e5       	ldi	r25, 0x59	; 89
    14b0:	a1 e0       	ldi	r26, 0x01	; 1
    14b2:	81 50       	subi	r24, 0x01	; 1
    14b4:	90 40       	sbci	r25, 0x00	; 0
    14b6:	a0 40       	sbci	r26, 0x00	; 0
    14b8:	e1 f7       	brne	.-8      	; 0x14b2 <place_block+0x52>
    14ba:	00 00       	nop
		servo_1(i);
		_delay_ms(60);
	}
	servo_2(100);
	_delay_ms(500);
	for (i = 84; i < 130; i++)
    14bc:	80 91 30 02 	lds	r24, 0x0230
    14c0:	8f 5f       	subi	r24, 0xFF	; 255
    14c2:	80 93 30 02 	sts	0x0230, r24
    14c6:	82 38       	cpi	r24, 0x82	; 130
    14c8:	78 f3       	brcs	.-34     	; 0x14a8 <place_block+0x48>
	{
		servo_1(i);
		_delay_ms(30);
	}
	servo_2(120);
    14ca:	88 e7       	ldi	r24, 0x78	; 120
    14cc:	0e 94 09 0a 	call	0x1412	; 0x1412 <servo_2>
}
    14d0:	08 95       	ret

000014d2 <place_to_sort>:

void place_to_sort()
{
	for (i = 160; i > 84; i--)
    14d2:	80 ea       	ldi	r24, 0xA0	; 160
    14d4:	80 93 30 02 	sts	0x0230, r24
	{
		servo_1(i);
    14d8:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <servo_1>
    14dc:	89 e9       	ldi	r24, 0x99	; 153
    14de:	99 e5       	ldi	r25, 0x59	; 89
    14e0:	a1 e0       	ldi	r26, 0x01	; 1
    14e2:	81 50       	subi	r24, 0x01	; 1
    14e4:	90 40       	sbci	r25, 0x00	; 0
    14e6:	a0 40       	sbci	r26, 0x00	; 0
    14e8:	e1 f7       	brne	.-8      	; 0x14e2 <place_to_sort+0x10>
    14ea:	00 00       	nop
	servo_2(120);
}

void place_to_sort()
{
	for (i = 160; i > 84; i--)
    14ec:	80 91 30 02 	lds	r24, 0x0230
    14f0:	81 50       	subi	r24, 0x01	; 1
    14f2:	80 93 30 02 	sts	0x0230, r24
    14f6:	85 35       	cpi	r24, 0x55	; 85
    14f8:	78 f7       	brcc	.-34     	; 0x14d8 <place_to_sort+0x6>
	{
		servo_1(i);
		_delay_ms(30);
	}
	servo_2(85);
    14fa:	85 e5       	ldi	r24, 0x55	; 85
    14fc:	0e 94 09 0a 	call	0x1412	; 0x1412 <servo_2>
    1500:	8f ef       	ldi	r24, 0xFF	; 255
    1502:	9f e7       	ldi	r25, 0x7F	; 127
    1504:	a6 e1       	ldi	r26, 0x16	; 22
    1506:	81 50       	subi	r24, 0x01	; 1
    1508:	90 40       	sbci	r25, 0x00	; 0
    150a:	a0 40       	sbci	r26, 0x00	; 0
    150c:	e1 f7       	brne	.-8      	; 0x1506 <place_to_sort+0x34>
    150e:	00 c0       	rjmp	.+0      	; 0x1510 <place_to_sort+0x3e>
    1510:	00 00       	nop
	_delay_ms(500);
	for (i = 84; i < 130; i++)
    1512:	84 e5       	ldi	r24, 0x54	; 84
    1514:	80 93 30 02 	sts	0x0230, r24
	{
		servo_1(i);
    1518:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <servo_1>
    151c:	89 e9       	ldi	r24, 0x99	; 153
    151e:	99 e5       	ldi	r25, 0x59	; 89
    1520:	a1 e0       	ldi	r26, 0x01	; 1
    1522:	81 50       	subi	r24, 0x01	; 1
    1524:	90 40       	sbci	r25, 0x00	; 0
    1526:	a0 40       	sbci	r26, 0x00	; 0
    1528:	e1 f7       	brne	.-8      	; 0x1522 <place_to_sort+0x50>
    152a:	00 00       	nop
		servo_1(i);
		_delay_ms(30);
	}
	servo_2(85);
	_delay_ms(500);
	for (i = 84; i < 130; i++)
    152c:	80 91 30 02 	lds	r24, 0x0230
    1530:	8f 5f       	subi	r24, 0xFF	; 255
    1532:	80 93 30 02 	sts	0x0230, r24
    1536:	82 38       	cpi	r24, 0x82	; 130
    1538:	78 f3       	brcs	.-34     	; 0x1518 <place_to_sort+0x46>
	{
		servo_1(i);
		_delay_ms(30);
	}
}
    153a:	08 95       	ret

0000153c <pick_block>:

void pick_block(int angle)
{
    153c:	0f 93       	push	r16
    153e:	1f 93       	push	r17
    1540:	cf 93       	push	r28
    1542:	df 93       	push	r29
    1544:	ec 01       	movw	r28, r24
	for (i = 130; i > angle; i--)
    1546:	82 e8       	ldi	r24, 0x82	; 130
    1548:	80 93 30 02 	sts	0x0230, r24
    154c:	c2 38       	cpi	r28, 0x82	; 130
    154e:	d1 05       	cpc	r29, r1
    1550:	a4 f4       	brge	.+40     	; 0x157a <pick_block+0x3e>
	{
		servo_1(i);
    1552:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <servo_1>
    1556:	89 e9       	ldi	r24, 0x99	; 153
    1558:	99 e5       	ldi	r25, 0x59	; 89
    155a:	a1 e0       	ldi	r26, 0x01	; 1
    155c:	81 50       	subi	r24, 0x01	; 1
    155e:	90 40       	sbci	r25, 0x00	; 0
    1560:	a0 40       	sbci	r26, 0x00	; 0
    1562:	e1 f7       	brne	.-8      	; 0x155c <pick_block+0x20>
    1564:	00 00       	nop
	}
}

void pick_block(int angle)
{
	for (i = 130; i > angle; i--)
    1566:	80 91 30 02 	lds	r24, 0x0230
    156a:	81 50       	subi	r24, 0x01	; 1
    156c:	80 93 30 02 	sts	0x0230, r24
    1570:	28 2f       	mov	r18, r24
    1572:	30 e0       	ldi	r19, 0x00	; 0
    1574:	c2 17       	cp	r28, r18
    1576:	d3 07       	cpc	r29, r19
    1578:	64 f3       	brlt	.-40     	; 0x1552 <pick_block+0x16>
	{
		servo_1(i);
		_delay_ms(30);
	}
	 i=120;
    157a:	88 e7       	ldi	r24, 0x78	; 120
    157c:	80 93 30 02 	sts	0x0230, r24
	 //buzzer_on();
	 while(grip_switch == 0x40)
    1580:	80 91 0f 02 	lds	r24, 0x020F
    1584:	80 34       	cpi	r24, 0x40	; 64
    1586:	41 f0       	breq	.+16     	; 0x1598 <pick_block+0x5c>
    1588:	1f c0       	rjmp	.+62     	; 0x15c8 <pick_block+0x8c>
	 {
		 if (i == 55){
    158a:	80 91 30 02 	lds	r24, 0x0230
    158e:	87 33       	cpi	r24, 0x37	; 55
    1590:	31 f4       	brne	.+12     	; 0x159e <pick_block+0x62>
			 buzzer_off();
    1592:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
			break;
    1596:	18 c0       	rjmp	.+48     	; 0x15c8 <pick_block+0x8c>
	}
	 i=120;
	 //buzzer_on();
	 while(grip_switch == 0x40)
	 {
		 if (i == 55){
    1598:	88 e7       	ldi	r24, 0x78	; 120
			break;
		 }			
		 servo_2(i);
		 _delay_ms(45);
		 i--;
		 grip_switch = PINL;
    159a:	09 e0       	ldi	r16, 0x09	; 9
    159c:	11 e0       	ldi	r17, 0x01	; 1
	 {
		 if (i == 55){
			 buzzer_off();
			break;
		 }			
		 servo_2(i);
    159e:	0e 94 09 0a 	call	0x1412	; 0x1412 <servo_2>
    15a2:	86 e6       	ldi	r24, 0x66	; 102
    15a4:	96 e0       	ldi	r25, 0x06	; 6
    15a6:	a2 e0       	ldi	r26, 0x02	; 2
    15a8:	81 50       	subi	r24, 0x01	; 1
    15aa:	90 40       	sbci	r25, 0x00	; 0
    15ac:	a0 40       	sbci	r26, 0x00	; 0
    15ae:	e1 f7       	brne	.-8      	; 0x15a8 <pick_block+0x6c>
		 _delay_ms(45);
		 i--;
    15b0:	80 91 30 02 	lds	r24, 0x0230
    15b4:	81 50       	subi	r24, 0x01	; 1
    15b6:	80 93 30 02 	sts	0x0230, r24
		 grip_switch = PINL;
    15ba:	d8 01       	movw	r26, r16
    15bc:	8c 91       	ld	r24, X
		 grip_switch = grip_switch & 0x40;
    15be:	80 74       	andi	r24, 0x40	; 64
    15c0:	80 93 0f 02 	sts	0x020F, r24
		servo_1(i);
		_delay_ms(30);
	}
	 i=120;
	 //buzzer_on();
	 while(grip_switch == 0x40)
    15c4:	80 34       	cpi	r24, 0x40	; 64
    15c6:	09 f3       	breq	.-62     	; 0x158a <pick_block+0x4e>
		 i--;
		 grip_switch = PINL;
		 grip_switch = grip_switch & 0x40;
		
	 }
	  buzzer_on();
    15c8:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    15cc:	8c ec       	ldi	r24, 0xCC	; 204
    15ce:	9c ec       	ldi	r25, 0xCC	; 204
    15d0:	a1 e0       	ldi	r26, 0x01	; 1
    15d2:	81 50       	subi	r24, 0x01	; 1
    15d4:	90 40       	sbci	r25, 0x00	; 0
    15d6:	a0 40       	sbci	r26, 0x00	; 0
    15d8:	e1 f7       	brne	.-8      	; 0x15d2 <pick_block+0x96>
    15da:	00 c0       	rjmp	.+0      	; 0x15dc <pick_block+0xa0>
	 _delay_ms(40);
	buzzer_off();
    15dc:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
	 //servo_2(i-=2);
	 //_delay_ms(30);
	for (i = angle; i < 160; i++)
    15e0:	8c 2f       	mov	r24, r28
    15e2:	c0 93 30 02 	sts	0x0230, r28
    15e6:	c0 3a       	cpi	r28, 0xA0	; 160
    15e8:	90 f4       	brcc	.+36     	; 0x160e <pick_block+0xd2>
	{
		servo_1(i);
    15ea:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <servo_1>
    15ee:	8f ef       	ldi	r24, 0xFF	; 255
    15f0:	9f e1       	ldi	r25, 0x1F	; 31
    15f2:	a1 e0       	ldi	r26, 0x01	; 1
    15f4:	81 50       	subi	r24, 0x01	; 1
    15f6:	90 40       	sbci	r25, 0x00	; 0
    15f8:	a0 40       	sbci	r26, 0x00	; 0
    15fa:	e1 f7       	brne	.-8      	; 0x15f4 <pick_block+0xb8>
    15fc:	00 c0       	rjmp	.+0      	; 0x15fe <pick_block+0xc2>
    15fe:	00 00       	nop
	  buzzer_on();
	 _delay_ms(40);
	buzzer_off();
	 //servo_2(i-=2);
	 //_delay_ms(30);
	for (i = angle; i < 160; i++)
    1600:	80 91 30 02 	lds	r24, 0x0230
    1604:	8f 5f       	subi	r24, 0xFF	; 255
    1606:	80 93 30 02 	sts	0x0230, r24
    160a:	80 3a       	cpi	r24, 0xA0	; 160
    160c:	70 f3       	brcs	.-36     	; 0x15ea <pick_block+0xae>
	{
		servo_1(i);
		_delay_ms(25);
	}
}
    160e:	df 91       	pop	r29
    1610:	cf 91       	pop	r28
    1612:	1f 91       	pop	r17
    1614:	0f 91       	pop	r16
    1616:	08 95       	ret

00001618 <pick_at_sort>:

void pick_at_sort()
{
    1618:	cf 93       	push	r28
    161a:	df 93       	push	r29
	for (i = 130; i > 86; i--)
    161c:	82 e8       	ldi	r24, 0x82	; 130
    161e:	80 93 30 02 	sts	0x0230, r24
	{
		servo_1(i);
    1622:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <servo_1>
    1626:	89 e9       	ldi	r24, 0x99	; 153
    1628:	99 e5       	ldi	r25, 0x59	; 89
    162a:	a1 e0       	ldi	r26, 0x01	; 1
    162c:	81 50       	subi	r24, 0x01	; 1
    162e:	90 40       	sbci	r25, 0x00	; 0
    1630:	a0 40       	sbci	r26, 0x00	; 0
    1632:	e1 f7       	brne	.-8      	; 0x162c <pick_at_sort+0x14>
    1634:	00 00       	nop
	}
}

void pick_at_sort()
{
	for (i = 130; i > 86; i--)
    1636:	80 91 30 02 	lds	r24, 0x0230
    163a:	81 50       	subi	r24, 0x01	; 1
    163c:	80 93 30 02 	sts	0x0230, r24
    1640:	87 35       	cpi	r24, 0x57	; 87
    1642:	78 f7       	brcc	.-34     	; 0x1622 <pick_at_sort+0xa>
	{
		servo_1(i);
		_delay_ms(30);
	}
	i=90;
    1644:	8a e5       	ldi	r24, 0x5A	; 90
    1646:	80 93 30 02 	sts	0x0230, r24
	//buzzer_on();
	while(grip_switch == 0x40)
    164a:	80 91 0f 02 	lds	r24, 0x020F
    164e:	80 34       	cpi	r24, 0x40	; 64
    1650:	41 f0       	breq	.+16     	; 0x1662 <pick_at_sort+0x4a>
    1652:	41 c0       	rjmp	.+130    	; 0x16d6 <pick_at_sort+0xbe>
	{
		if (i == 55){
    1654:	80 91 30 02 	lds	r24, 0x0230
    1658:	87 33       	cpi	r24, 0x37	; 55
    165a:	31 f4       	brne	.+12     	; 0x1668 <pick_at_sort+0x50>
			buzzer_off();
    165c:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
			break;
    1660:	17 c0       	rjmp	.+46     	; 0x1690 <pick_at_sort+0x78>
	}
	i=90;
	//buzzer_on();
	while(grip_switch == 0x40)
	{
		if (i == 55){
    1662:	8a e5       	ldi	r24, 0x5A	; 90
			break;
		}
		servo_2(i);
		_delay_ms(45);
		i--;
		grip_switch = PINL;
    1664:	c9 e0       	ldi	r28, 0x09	; 9
    1666:	d1 e0       	ldi	r29, 0x01	; 1
	{
		if (i == 55){
			buzzer_off();
			break;
		}
		servo_2(i);
    1668:	0e 94 09 0a 	call	0x1412	; 0x1412 <servo_2>
    166c:	86 e6       	ldi	r24, 0x66	; 102
    166e:	96 e0       	ldi	r25, 0x06	; 6
    1670:	a2 e0       	ldi	r26, 0x02	; 2
    1672:	81 50       	subi	r24, 0x01	; 1
    1674:	90 40       	sbci	r25, 0x00	; 0
    1676:	a0 40       	sbci	r26, 0x00	; 0
    1678:	e1 f7       	brne	.-8      	; 0x1672 <pick_at_sort+0x5a>
		_delay_ms(45);
		i--;
    167a:	80 91 30 02 	lds	r24, 0x0230
    167e:	81 50       	subi	r24, 0x01	; 1
    1680:	80 93 30 02 	sts	0x0230, r24
		grip_switch = PINL;
    1684:	88 81       	ld	r24, Y
		grip_switch = grip_switch & 0x40;
    1686:	80 74       	andi	r24, 0x40	; 64
    1688:	80 93 0f 02 	sts	0x020F, r24
		servo_1(i);
		_delay_ms(30);
	}
	i=90;
	//buzzer_on();
	while(grip_switch == 0x40)
    168c:	80 34       	cpi	r24, 0x40	; 64
    168e:	11 f3       	breq	.-60     	; 0x1654 <pick_at_sort+0x3c>
		i--;
		grip_switch = PINL;
		grip_switch = grip_switch & 0x40;
		
	}
	buzzer_on();
    1690:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    1694:	8c ec       	ldi	r24, 0xCC	; 204
    1696:	9c ec       	ldi	r25, 0xCC	; 204
    1698:	a1 e0       	ldi	r26, 0x01	; 1
    169a:	81 50       	subi	r24, 0x01	; 1
    169c:	90 40       	sbci	r25, 0x00	; 0
    169e:	a0 40       	sbci	r26, 0x00	; 0
    16a0:	e1 f7       	brne	.-8      	; 0x169a <pick_at_sort+0x82>
    16a2:	00 c0       	rjmp	.+0      	; 0x16a4 <pick_at_sort+0x8c>
	_delay_ms(40);
	buzzer_off();
    16a4:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
	//servo_2(i-=2);
	//_delay_ms(30);
	for (i = 86; i < 160; i++)
    16a8:	86 e5       	ldi	r24, 0x56	; 86
    16aa:	80 93 30 02 	sts	0x0230, r24
    16ae:	22 c0       	rjmp	.+68     	; 0x16f4 <pick_at_sort+0xdc>
	{
		servo_1(i);
    16b0:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <servo_1>
    16b4:	8f ef       	ldi	r24, 0xFF	; 255
    16b6:	9f e1       	ldi	r25, 0x1F	; 31
    16b8:	a1 e0       	ldi	r26, 0x01	; 1
    16ba:	81 50       	subi	r24, 0x01	; 1
    16bc:	90 40       	sbci	r25, 0x00	; 0
    16be:	a0 40       	sbci	r26, 0x00	; 0
    16c0:	e1 f7       	brne	.-8      	; 0x16ba <pick_at_sort+0xa2>
    16c2:	00 c0       	rjmp	.+0      	; 0x16c4 <pick_at_sort+0xac>
    16c4:	00 00       	nop
	buzzer_on();
	_delay_ms(40);
	buzzer_off();
	//servo_2(i-=2);
	//_delay_ms(30);
	for (i = 86; i < 160; i++)
    16c6:	80 91 30 02 	lds	r24, 0x0230
    16ca:	8f 5f       	subi	r24, 0xFF	; 255
    16cc:	80 93 30 02 	sts	0x0230, r24
    16d0:	80 3a       	cpi	r24, 0xA0	; 160
    16d2:	70 f3       	brcs	.-36     	; 0x16b0 <pick_at_sort+0x98>
    16d4:	11 c0       	rjmp	.+34     	; 0x16f8 <pick_at_sort+0xe0>
		i--;
		grip_switch = PINL;
		grip_switch = grip_switch & 0x40;
		
	}
	buzzer_on();
    16d6:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    16da:	8c ec       	ldi	r24, 0xCC	; 204
    16dc:	9c ec       	ldi	r25, 0xCC	; 204
    16de:	a1 e0       	ldi	r26, 0x01	; 1
    16e0:	81 50       	subi	r24, 0x01	; 1
    16e2:	90 40       	sbci	r25, 0x00	; 0
    16e4:	a0 40       	sbci	r26, 0x00	; 0
    16e6:	e1 f7       	brne	.-8      	; 0x16e0 <pick_at_sort+0xc8>
    16e8:	00 c0       	rjmp	.+0      	; 0x16ea <pick_at_sort+0xd2>
	_delay_ms(40);
	buzzer_off();
    16ea:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
	//servo_2(i-=2);
	//_delay_ms(30);
	for (i = 86; i < 160; i++)
    16ee:	86 e5       	ldi	r24, 0x56	; 86
    16f0:	80 93 30 02 	sts	0x0230, r24
	}
	i=90;
	//buzzer_on();
	while(grip_switch == 0x40)
	{
		if (i == 55){
    16f4:	86 e5       	ldi	r24, 0x56	; 86
    16f6:	dc cf       	rjmp	.-72     	; 0x16b0 <pick_at_sort+0x98>
	for (i = 86; i < 160; i++)
	{
		servo_1(i);
		_delay_ms(25);
	}
}
    16f8:	df 91       	pop	r29
    16fa:	cf 91       	pop	r28
    16fc:	08 95       	ret

000016fe <drop_weight>:

void drop_weight()
{
	for (i = 120; i > 108; i--)
    16fe:	88 e7       	ldi	r24, 0x78	; 120
    1700:	80 93 30 02 	sts	0x0230, r24
	{
		servo_1(i);
    1704:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <servo_1>
    1708:	89 e9       	ldi	r24, 0x99	; 153
    170a:	99 e5       	ldi	r25, 0x59	; 89
    170c:	a1 e0       	ldi	r26, 0x01	; 1
    170e:	81 50       	subi	r24, 0x01	; 1
    1710:	90 40       	sbci	r25, 0x00	; 0
    1712:	a0 40       	sbci	r26, 0x00	; 0
    1714:	e1 f7       	brne	.-8      	; 0x170e <drop_weight+0x10>
    1716:	00 00       	nop
	}
}

void drop_weight()
{
	for (i = 120; i > 108; i--)
    1718:	80 91 30 02 	lds	r24, 0x0230
    171c:	81 50       	subi	r24, 0x01	; 1
    171e:	80 93 30 02 	sts	0x0230, r24
    1722:	8d 36       	cpi	r24, 0x6D	; 109
    1724:	78 f7       	brcc	.-34     	; 0x1704 <drop_weight+0x6>
	{
		servo_1(i);
		_delay_ms(30);
	}
	servo_2(120);
    1726:	88 e7       	ldi	r24, 0x78	; 120
    1728:	0e 94 09 0a 	call	0x1412	; 0x1412 <servo_2>
    172c:	8f ef       	ldi	r24, 0xFF	; 255
    172e:	9f e7       	ldi	r25, 0x7F	; 127
    1730:	a4 e0       	ldi	r26, 0x04	; 4
    1732:	81 50       	subi	r24, 0x01	; 1
    1734:	90 40       	sbci	r25, 0x00	; 0
    1736:	a0 40       	sbci	r26, 0x00	; 0
    1738:	e1 f7       	brne	.-8      	; 0x1732 <drop_weight+0x34>
    173a:	00 c0       	rjmp	.+0      	; 0x173c <drop_weight+0x3e>
    173c:	00 00       	nop
	_delay_ms(100);
	for (i = 108; i < 120; i++)
    173e:	8c e6       	ldi	r24, 0x6C	; 108
    1740:	80 93 30 02 	sts	0x0230, r24
	{
		servo_1(i);
    1744:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <servo_1>
    1748:	89 e9       	ldi	r24, 0x99	; 153
    174a:	99 e5       	ldi	r25, 0x59	; 89
    174c:	a1 e0       	ldi	r26, 0x01	; 1
    174e:	81 50       	subi	r24, 0x01	; 1
    1750:	90 40       	sbci	r25, 0x00	; 0
    1752:	a0 40       	sbci	r26, 0x00	; 0
    1754:	e1 f7       	brne	.-8      	; 0x174e <drop_weight+0x50>
    1756:	00 00       	nop
		servo_1(i);
		_delay_ms(30);
	}
	servo_2(120);
	_delay_ms(100);
	for (i = 108; i < 120; i++)
    1758:	80 91 30 02 	lds	r24, 0x0230
    175c:	8f 5f       	subi	r24, 0xFF	; 255
    175e:	80 93 30 02 	sts	0x0230, r24
    1762:	88 37       	cpi	r24, 0x78	; 120
    1764:	78 f3       	brcs	.-34     	; 0x1744 <drop_weight+0x46>
	{
		servo_1(i);
		_delay_ms(30);
	}
}
    1766:	08 95       	ret

00001768 <node0_0>:
int a_flag=0, b_flag = 0, c_flag = 0;
//int valid=0;


int node0_0(int flag, int angle)	//contains code for node_0_1
{
    1768:	cf 93       	push	r28
    176a:	df 93       	push	r29
    176c:	eb 01       	movw	r28, r22
	if (flag==0)					//turn left
    176e:	00 97       	sbiw	r24, 0x00	; 0
    1770:	89 f4       	brne	.+34     	; 0x1794 <node0_0+0x2c>
	{
		velocity(180,180);
    1772:	84 eb       	ldi	r24, 0xB4	; 180
    1774:	64 eb       	ldi	r22, 0xB4	; 180
    1776:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
		backward_mm(20);
    177a:	84 e1       	ldi	r24, 0x14	; 20
    177c:	90 e0       	ldi	r25, 0x00	; 0
    177e:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		left_degrees(67,1);//100/70
    1782:	83 e4       	ldi	r24, 0x43	; 67
    1784:	90 e0       	ldi	r25, 0x00	; 0
    1786:	61 e0       	ldi	r22, 0x01	; 1
    1788:	70 e0       	ldi	r23, 0x00	; 0
    178a:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
		fw_follow_black_line();
    178e:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
    1792:	a0 c0       	rjmp	.+320    	; 0x18d4 <node0_0+0x16c>
		/*
		soft_left();
		_delay_ms(3);*/
		
	}
	else if (flag==1)				//turn right towards sorting zone
    1794:	81 30       	cpi	r24, 0x01	; 1
    1796:	91 05       	cpc	r25, r1
    1798:	d1 f4       	brne	.+52     	; 0x17ce <node0_0+0x66>
    179a:	8f ef       	ldi	r24, 0xFF	; 255
    179c:	9f e7       	ldi	r25, 0x7F	; 127
    179e:	a4 e0       	ldi	r26, 0x04	; 4
    17a0:	81 50       	subi	r24, 0x01	; 1
    17a2:	90 40       	sbci	r25, 0x00	; 0
    17a4:	a0 40       	sbci	r26, 0x00	; 0
    17a6:	e1 f7       	brne	.-8      	; 0x17a0 <node0_0+0x38>
    17a8:	00 c0       	rjmp	.+0      	; 0x17aa <node0_0+0x42>
    17aa:	00 00       	nop
	{
		_delay_ms(100);
		velocity(180,180);
    17ac:	84 eb       	ldi	r24, 0xB4	; 180
    17ae:	64 eb       	ldi	r22, 0xB4	; 180
    17b0:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
		
		forward_mm(60);//100
    17b4:	8c e3       	ldi	r24, 0x3C	; 60
    17b6:	90 e0       	ldi	r25, 0x00	; 0
    17b8:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
		/*
		soft_right_2();  
		_delay_ms(2525);//1550 1560 removed*/
		right_degrees(84,0);// 104, 0,80
    17bc:	84 e5       	ldi	r24, 0x54	; 84
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	60 e0       	ldi	r22, 0x00	; 0
    17c2:	70 e0       	ldi	r23, 0x00	; 0
    17c4:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		forward_mm(10);
		pick_block(angle);
		backward_mm(30);
		left_degrees(185,0);
		*/
		fw_follow_black_line();
    17c8:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
    17cc:	83 c0       	rjmp	.+262    	; 0x18d4 <node0_0+0x16c>
	}
	else if (flag==2)				//go straight on the bridge
    17ce:	82 30       	cpi	r24, 0x02	; 2
    17d0:	91 05       	cpc	r25, r1
    17d2:	19 f4       	brne	.+6      	; 0x17da <node0_0+0x72>
	{
		fw_follow_black_line();
    17d4:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
    17d8:	7d c0       	rjmp	.+250    	; 0x18d4 <node0_0+0x16c>
	}
	else if (flag==3)			//turn right and pick weight block
    17da:	83 30       	cpi	r24, 0x03	; 3
    17dc:	91 05       	cpc	r25, r1
    17de:	91 f4       	brne	.+36     	; 0x1804 <node0_0+0x9c>
	{
		right_degrees(100,0);
    17e0:	84 e6       	ldi	r24, 0x64	; 100
    17e2:	90 e0       	ldi	r25, 0x00	; 0
    17e4:	60 e0       	ldi	r22, 0x00	; 0
    17e6:	70 e0       	ldi	r23, 0x00	; 0
    17e8:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		fw_follow_black_line();
    17ec:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
		left_degrees(100,0);
    17f0:	84 e6       	ldi	r24, 0x64	; 100
    17f2:	90 e0       	ldi	r25, 0x00	; 0
    17f4:	60 e0       	ldi	r22, 0x00	; 0
    17f6:	70 e0       	ldi	r23, 0x00	; 0
    17f8:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
		pick_block(angle);
    17fc:	ce 01       	movw	r24, r28
    17fe:	0e 94 9e 0a 	call	0x153c	; 0x153c <pick_block>
    1802:	68 c0       	rjmp	.+208    	; 0x18d4 <node0_0+0x16c>
	}
	else if(flag == 4){
    1804:	84 30       	cpi	r24, 0x04	; 4
    1806:	91 05       	cpc	r25, r1
    1808:	49 f5       	brne	.+82     	; 0x185c <node0_0+0xf4>
		servo_1(130);
    180a:	82 e8       	ldi	r24, 0x82	; 130
    180c:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <servo_1>
		servo_2(120);
    1810:	88 e7       	ldi	r24, 0x78	; 120
    1812:	0e 94 09 0a 	call	0x1412	; 0x1412 <servo_2>
		velocity(180,180);
    1816:	84 eb       	ldi	r24, 0xB4	; 180
    1818:	64 eb       	ldi	r22, 0xB4	; 180
    181a:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
		left_degrees(169,1); //165,1/164
    181e:	89 ea       	ldi	r24, 0xA9	; 169
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	61 e0       	ldi	r22, 0x01	; 1
    1824:	70 e0       	ldi	r23, 0x00	; 0
    1826:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
		//left_degrees(95,0);	//temp
		backward_mm(23);//30
    182a:	87 e1       	ldi	r24, 0x17	; 23
    182c:	90 e0       	ldi	r25, 0x00	; 0
    182e:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		forward_mm(10);
    1832:	8a e0       	ldi	r24, 0x0A	; 10
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
		backward_mm(15);
    183a:	8f e0       	ldi	r24, 0x0F	; 15
    183c:	90 e0       	ldi	r25, 0x00	; 0
    183e:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		pick_block(107);
    1842:	8b e6       	ldi	r24, 0x6B	; 107
    1844:	90 e0       	ldi	r25, 0x00	; 0
    1846:	0e 94 9e 0a 	call	0x153c	; 0x153c <pick_block>
		forward_mm(15);
    184a:	8f e0       	ldi	r24, 0x0F	; 15
    184c:	90 e0       	ldi	r25, 0x00	; 0
    184e:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
		backward_mm(100);
    1852:	84 e6       	ldi	r24, 0x64	; 100
    1854:	90 e0       	ldi	r25, 0x00	; 0
    1856:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
    185a:	3c c0       	rjmp	.+120    	; 0x18d4 <node0_0+0x16c>
	}
	else if(flag==5){
    185c:	85 30       	cpi	r24, 0x05	; 5
    185e:	91 05       	cpc	r25, r1
    1860:	a9 f4       	brne	.+42     	; 0x188c <node0_0+0x124>
		forward_mm(50);
    1862:	82 e3       	ldi	r24, 0x32	; 50
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
		pick_block(96);
    186a:	80 e6       	ldi	r24, 0x60	; 96
    186c:	90 e0       	ldi	r25, 0x00	; 0
    186e:	0e 94 9e 0a 	call	0x153c	; 0x153c <pick_block>
		backward_mm(60);
    1872:	8c e3       	ldi	r24, 0x3C	; 60
    1874:	90 e0       	ldi	r25, 0x00	; 0
    1876:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		right_degrees(88,0);
    187a:	88 e5       	ldi	r24, 0x58	; 88
    187c:	90 e0       	ldi	r25, 0x00	; 0
    187e:	60 e0       	ldi	r22, 0x00	; 0
    1880:	70 e0       	ldi	r23, 0x00	; 0
    1882:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		fw_follow_black_line();
    1886:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
    188a:	24 c0       	rjmp	.+72     	; 0x18d4 <node0_0+0x16c>
	}
	else if(flag==6){
    188c:	86 30       	cpi	r24, 0x06	; 6
    188e:	91 05       	cpc	r25, r1
    1890:	09 f5       	brne	.+66     	; 0x18d4 <node0_0+0x16c>
		servo_2(120);
    1892:	88 e7       	ldi	r24, 0x78	; 120
    1894:	0e 94 09 0a 	call	0x1412	; 0x1412 <servo_2>
		forward_mm(70);
    1898:	86 e4       	ldi	r24, 0x46	; 70
    189a:	90 e0       	ldi	r25, 0x00	; 0
    189c:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
		pick_block(85);
    18a0:	85 e5       	ldi	r24, 0x55	; 85
    18a2:	90 e0       	ldi	r25, 0x00	; 0
    18a4:	0e 94 9e 0a 	call	0x153c	; 0x153c <pick_block>
		backward_mm(80);
    18a8:	80 e5       	ldi	r24, 0x50	; 80
    18aa:	90 e0       	ldi	r25, 0x00	; 0
    18ac:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		right_degrees(88,0);
    18b0:	88 e5       	ldi	r24, 0x58	; 88
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	60 e0       	ldi	r22, 0x00	; 0
    18b6:	70 e0       	ldi	r23, 0x00	; 0
    18b8:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		backward_mm(50);
    18bc:	82 e3       	ldi	r24, 0x32	; 50
    18be:	90 e0       	ldi	r25, 0x00	; 0
    18c0:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		right_degrees(88,0);
    18c4:	88 e5       	ldi	r24, 0x58	; 88
    18c6:	90 e0       	ldi	r25, 0x00	; 0
    18c8:	60 e0       	ldi	r22, 0x00	; 0
    18ca:	70 e0       	ldi	r23, 0x00	; 0
    18cc:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		fw_follow_black_line();
    18d0:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
	}
}
    18d4:	df 91       	pop	r29
    18d6:	cf 91       	pop	r28
    18d8:	08 95       	ret

000018da <node_m1_0>:

int node_m1_0(int flag)
{
    18da:	cf 93       	push	r28
    18dc:	df 93       	push	r29
    18de:	ec 01       	movw	r28, r24
	if(flag==0)				//turn right and drop weight block
    18e0:	00 97       	sbiw	r24, 0x00	; 0
    18e2:	d9 f4       	brne	.+54     	; 0x191a <node_m1_0+0x40>
	{
		velocity(180,180);
    18e4:	84 eb       	ldi	r24, 0xB4	; 180
    18e6:	64 eb       	ldi	r22, 0xB4	; 180
    18e8:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
		right_degrees(85,0);
    18ec:	85 e5       	ldi	r24, 0x55	; 85
    18ee:	90 e0       	ldi	r25, 0x00	; 0
    18f0:	60 e0       	ldi	r22, 0x00	; 0
    18f2:	70 e0       	ldi	r23, 0x00	; 0
    18f4:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		backward_mm(20);
    18f8:	84 e1       	ldi	r24, 0x14	; 20
    18fa:	90 e0       	ldi	r25, 0x00	; 0
    18fc:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		drop_weight();
    1900:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <drop_weight>
		left_degrees(100,0);
    1904:	84 e6       	ldi	r24, 0x64	; 100
    1906:	90 e0       	ldi	r25, 0x00	; 0
    1908:	60 e0       	ldi	r22, 0x00	; 0
    190a:	70 e0       	ldi	r23, 0x00	; 0
    190c:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
		fw_follow_black_line();
    1910:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
		stop();
    1914:	0e 94 21 03 	call	0x642	; 0x642 <stop>
    1918:	2c c0       	rjmp	.+88     	; 0x1972 <node_m1_0+0x98>
		//return 1;
	}
	if(flag==1)
    191a:	81 30       	cpi	r24, 0x01	; 1
    191c:	91 05       	cpc	r25, r1
    191e:	d9 f4       	brne	.+54     	; 0x1956 <node_m1_0+0x7c>
	{
		velocity(180,180);
    1920:	84 eb       	ldi	r24, 0xB4	; 180
    1922:	64 eb       	ldi	r22, 0xB4	; 180
    1924:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
		right_degrees(85,0);
    1928:	85 e5       	ldi	r24, 0x55	; 85
    192a:	90 e0       	ldi	r25, 0x00	; 0
    192c:	60 e0       	ldi	r22, 0x00	; 0
    192e:	70 e0       	ldi	r23, 0x00	; 0
    1930:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		backward_mm(20);
    1934:	84 e1       	ldi	r24, 0x14	; 20
    1936:	90 e0       	ldi	r25, 0x00	; 0
    1938:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		drop_weight();
    193c:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <drop_weight>
		right_degrees(100,0);
    1940:	84 e6       	ldi	r24, 0x64	; 100
    1942:	90 e0       	ldi	r25, 0x00	; 0
    1944:	60 e0       	ldi	r22, 0x00	; 0
    1946:	70 e0       	ldi	r23, 0x00	; 0
    1948:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		stop();
    194c:	0e 94 21 03 	call	0x642	; 0x642 <stop>
		return 2;
    1950:	22 e0       	ldi	r18, 0x02	; 2
    1952:	30 e0       	ldi	r19, 0x00	; 0
    1954:	16 c0       	rjmp	.+44     	; 0x1982 <node_m1_0+0xa8>
	}
	if(flag==2)					//go straight
    1956:	82 30       	cpi	r24, 0x02	; 2
    1958:	91 05       	cpc	r25, r1
    195a:	59 f4       	brne	.+22     	; 0x1972 <node_m1_0+0x98>
	{
		//_delay_ms(100);
		//fw_follow_black_line();
		velocity(150,200);
    195c:	86 e9       	ldi	r24, 0x96	; 150
    195e:	68 ec       	ldi	r22, 0xC8	; 200
    1960:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
		forward_mm(195);
    1964:	83 ec       	ldi	r24, 0xC3	; 195
    1966:	90 e0       	ldi	r25, 0x00	; 0
    1968:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
		/*
		soft_left();
		_delay_ms(3);
		*/
		return 1;
    196c:	21 e0       	ldi	r18, 0x01	; 1
    196e:	30 e0       	ldi	r19, 0x00	; 0
    1970:	08 c0       	rjmp	.+16     	; 0x1982 <node_m1_0+0xa8>
	}
	if(flag==3){
    1972:	c3 30       	cpi	r28, 0x03	; 3
    1974:	d1 05       	cpc	r29, r1
    1976:	21 f4       	brne	.+8      	; 0x1980 <node_m1_0+0xa6>
		fw_follow_black_line();
    1978:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
		stop();
    197c:	0e 94 21 03 	call	0x642	; 0x642 <stop>
    1980:	02 c0       	rjmp	.+4      	; 0x1986 <node_m1_0+0xac>
	}
}
    1982:	82 2f       	mov	r24, r18
    1984:	93 2f       	mov	r25, r19
    1986:	df 91       	pop	r29
    1988:	cf 91       	pop	r28
    198a:	08 95       	ret

0000198c <node_m2_0>:

int node_m2_0(int flag)
{
    198c:	cf 93       	push	r28
    198e:	df 93       	push	r29
	if (flag == 0) {				//pick weight block
    1990:	00 97       	sbiw	r24, 0x00	; 0
    1992:	79 f4       	brne	.+30     	; 0x19b2 <node_m2_0+0x26>
	pick_block(90);
    1994:	8a e5       	ldi	r24, 0x5A	; 90
    1996:	90 e0       	ldi	r25, 0x00	; 0
    1998:	0e 94 9e 0a 	call	0x153c	; 0x153c <pick_block>
	right_degrees(180,0);
    199c:	84 eb       	ldi	r24, 0xB4	; 180
    199e:	90 e0       	ldi	r25, 0x00	; 0
    19a0:	60 e0       	ldi	r22, 0x00	; 0
    19a2:	70 e0       	ldi	r23, 0x00	; 0
    19a4:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
	fw_follow_black_line();
    19a8:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
	return 1;
    19ac:	81 e0       	ldi	r24, 0x01	; 1
    19ae:	90 e0       	ldi	r25, 0x00	; 0
    19b0:	65 c0       	rjmp	.+202    	; 0x1a7c <node_m2_0+0xf0>
	
} else if (flag == 1) {			//place block in sorting zone
    19b2:	81 30       	cpi	r24, 0x01	; 1
    19b4:	91 05       	cpc	r25, r1
    19b6:	09 f0       	breq	.+2      	; 0x19ba <node_m2_0+0x2e>
    19b8:	61 c0       	rjmp	.+194    	; 0x1a7c <node_m2_0+0xf0>
	velocity(180,180);
    19ba:	84 eb       	ldi	r24, 0xB4	; 180
    19bc:	64 eb       	ldi	r22, 0xB4	; 180
    19be:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>

	right_degrees(76,1);//92/96/100/80/70
    19c2:	8c e4       	ldi	r24, 0x4C	; 76
    19c4:	90 e0       	ldi	r25, 0x00	; 0
    19c6:	61 e0       	ldi	r22, 0x01	; 1
    19c8:	70 e0       	ldi	r23, 0x00	; 0
    19ca:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
	backward_mm(25);
    19ce:	89 e1       	ldi	r24, 0x19	; 25
    19d0:	90 e0       	ldi	r25, 0x00	; 0
    19d2:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
	
	place_to_sort();
    19d6:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <place_to_sort>

	forward_mm(150);//130
    19da:	86 e9       	ldi	r24, 0x96	; 150
    19dc:	90 e0       	ldi	r25, 0x00	; 0
    19de:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
    19e2:	8f ef       	ldi	r24, 0xFF	; 255
    19e4:	9f ef       	ldi	r25, 0xFF	; 255
    19e6:	ac e2       	ldi	r26, 0x2C	; 44
    19e8:	81 50       	subi	r24, 0x01	; 1
    19ea:	90 40       	sbci	r25, 0x00	; 0
    19ec:	a0 40       	sbci	r26, 0x00	; 0
    19ee:	e1 f7       	brne	.-8      	; 0x19e8 <node_m2_0+0x5c>
    19f0:	00 c0       	rjmp	.+0      	; 0x19f2 <node_m2_0+0x66>
    19f2:	00 00       	nop
	//fw_follow_black_line();
	_delay_ms(1000);
	//forward_mm(4);
	sortedFlag[index] = detect_color();
    19f4:	c0 91 28 02 	lds	r28, 0x0228
    19f8:	d0 91 29 02 	lds	r29, 0x0229
    19fc:	0e 94 00 02 	call	0x400	; 0x400 <detect_color>
    1a00:	2a e2       	ldi	r18, 0x2A	; 42
    1a02:	32 e0       	ldi	r19, 0x02	; 2
    1a04:	cc 0f       	add	r28, r28
    1a06:	dd 1f       	adc	r29, r29
    1a08:	c2 0f       	add	r28, r18
    1a0a:	d3 1f       	adc	r29, r19
    1a0c:	99 83       	std	Y+1, r25	; 0x01
    1a0e:	88 83       	st	Y, r24
	index++;
    1a10:	80 91 28 02 	lds	r24, 0x0228
    1a14:	90 91 29 02 	lds	r25, 0x0229
    1a18:	ac 01       	movw	r20, r24
    1a1a:	4f 5f       	subi	r20, 0xFF	; 255
    1a1c:	5f 4f       	sbci	r21, 0xFF	; 255
    1a1e:	50 93 29 02 	sts	0x0229, r21
    1a22:	40 93 28 02 	sts	0x0228, r20
	print_color(sortedFlag[index - 1]);
    1a26:	88 0f       	add	r24, r24
    1a28:	99 1f       	adc	r25, r25
    1a2a:	28 0f       	add	r18, r24
    1a2c:	39 1f       	adc	r19, r25
    1a2e:	d9 01       	movw	r26, r18
    1a30:	8d 91       	ld	r24, X+
    1a32:	9c 91       	ld	r25, X
    1a34:	0e 94 bb 02 	call	0x576	; 0x576 <print_color>
	velocity(180,165);
    1a38:	84 eb       	ldi	r24, 0xB4	; 180
    1a3a:	65 ea       	ldi	r22, 0xA5	; 165
    1a3c:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>

	backward_mm(140);//160
    1a40:	8c e8       	ldi	r24, 0x8C	; 140
    1a42:	90 e0       	ldi	r25, 0x00	; 0
    1a44:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
	pick_at_sort();
    1a48:	0e 94 0c 0b 	call	0x1618	; 0x1618 <pick_at_sort>
	backward_mm(50);
    1a4c:	82 e3       	ldi	r24, 0x32	; 50
    1a4e:	90 e0       	ldi	r25, 0x00	; 0
    1a50:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
	right_degrees(73,1);//105/85/78//75
    1a54:	89 e4       	ldi	r24, 0x49	; 73
    1a56:	90 e0       	ldi	r25, 0x00	; 0
    1a58:	61 e0       	ldi	r22, 0x01	; 1
    1a5a:	70 e0       	ldi	r23, 0x00	; 0
    1a5c:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
	velocity(190,220);
    1a60:	8e eb       	ldi	r24, 0xBE	; 190
    1a62:	6c ed       	ldi	r22, 0xDC	; 220
    1a64:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
	backward_mm(30);
    1a68:	8e e1       	ldi	r24, 0x1E	; 30
    1a6a:	90 e0       	ldi	r25, 0x00	; 0
    1a6c:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
	fw_follow_black_line();
    1a70:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
	velocity(255,255);
    1a74:	8f ef       	ldi	r24, 0xFF	; 255
    1a76:	6f ef       	ldi	r22, 0xFF	; 255
    1a78:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
	}	
}
    1a7c:	df 91       	pop	r29
    1a7e:	cf 91       	pop	r28
    1a80:	08 95       	ret

00001a82 <node_0_1>:

int node_0_1(int flag,int valid)
{
    1a82:	cf 93       	push	r28
    1a84:	df 93       	push	r29
    1a86:	ec 01       	movw	r28, r24

	if (flag==0)				//detect color and place block if color matches
    1a88:	00 97       	sbiw	r24, 0x00	; 0
    1a8a:	09 f0       	breq	.+2      	; 0x1a8e <node_0_1+0xc>
    1a8c:	7d c0       	rjmp	.+250    	; 0x1b88 <node_0_1+0x106>
	{
		if(valid){
    1a8e:	61 15       	cp	r22, r1
    1a90:	71 05       	cpc	r23, r1
    1a92:	09 f4       	brne	.+2      	; 0x1a96 <node_0_1+0x14>
    1a94:	5a c0       	rjmp	.+180    	; 0x1b4a <node_0_1+0xc8>
		//fw_follow_black_line();
		forward_mm(190);
    1a96:	8e eb       	ldi	r24, 0xBE	; 190
    1a98:	90 e0       	ldi	r25, 0x00	; 0
    1a9a:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
	 	rotate_at_flag();
    1a9e:	0e 94 f6 07 	call	0xfec	; 0xfec <rotate_at_flag>
		b_flag=detect_color();
    1aa2:	0e 94 00 02 	call	0x400	; 0x400 <detect_color>
    1aa6:	90 93 25 02 	sts	0x0225, r25
    1aaa:	80 93 24 02 	sts	0x0224, r24
		print_color(b_flag);
    1aae:	0e 94 bb 02 	call	0x576	; 0x576 <print_color>
		backward_mm(50);
    1ab2:	82 e3       	ldi	r24, 0x32	; 50
    1ab4:	90 e0       	ldi	r25, 0x00	; 0
    1ab6:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		stop();
    1aba:	0e 94 21 03 	call	0x642	; 0x642 <stop>
    1abe:	8f ef       	ldi	r24, 0xFF	; 255
    1ac0:	9f e7       	ldi	r25, 0x7F	; 127
    1ac2:	a6 e1       	ldi	r26, 0x16	; 22
    1ac4:	81 50       	subi	r24, 0x01	; 1
    1ac6:	90 40       	sbci	r25, 0x00	; 0
    1ac8:	a0 40       	sbci	r26, 0x00	; 0
    1aca:	e1 f7       	brne	.-8      	; 0x1ac4 <node_0_1+0x42>
    1acc:	00 c0       	rjmp	.+0      	; 0x1ace <node_0_1+0x4c>
    1ace:	00 00       	nop
		_delay_ms(500);
		left_degrees(58,1);//60/62
    1ad0:	8a e3       	ldi	r24, 0x3A	; 58
    1ad2:	90 e0       	ldi	r25, 0x00	; 0
    1ad4:	61 e0       	ldi	r22, 0x01	; 1
    1ad6:	70 e0       	ldi	r23, 0x00	; 0
    1ad8:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
		stop();
    1adc:	0e 94 21 03 	call	0x642	; 0x642 <stop>
    1ae0:	8f ef       	ldi	r24, 0xFF	; 255
    1ae2:	9f e7       	ldi	r25, 0x7F	; 127
    1ae4:	a6 e1       	ldi	r26, 0x16	; 22
    1ae6:	81 50       	subi	r24, 0x01	; 1
    1ae8:	90 40       	sbci	r25, 0x00	; 0
    1aea:	a0 40       	sbci	r26, 0x00	; 0
    1aec:	e1 f7       	brne	.-8      	; 0x1ae6 <node_0_1+0x64>
    1aee:	00 c0       	rjmp	.+0      	; 0x1af0 <node_0_1+0x6e>
    1af0:	00 00       	nop
		_delay_ms(500);
		velocity(255,195);
    1af2:	8f ef       	ldi	r24, 0xFF	; 255
    1af4:	63 ec       	ldi	r22, 0xC3	; 195
    1af6:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
		backward_mm(150);//220/160
    1afa:	86 e9       	ldi	r24, 0x96	; 150
    1afc:	90 e0       	ldi	r25, 0x00	; 0
    1afe:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
	
		stop();
    1b02:	0e 94 21 03 	call	0x642	; 0x642 <stop>
    1b06:	8f ef       	ldi	r24, 0xFF	; 255
    1b08:	9f e7       	ldi	r25, 0x7F	; 127
    1b0a:	a6 e1       	ldi	r26, 0x16	; 22
    1b0c:	81 50       	subi	r24, 0x01	; 1
    1b0e:	90 40       	sbci	r25, 0x00	; 0
    1b10:	a0 40       	sbci	r26, 0x00	; 0
    1b12:	e1 f7       	brne	.-8      	; 0x1b0c <node_0_1+0x8a>
    1b14:	00 c0       	rjmp	.+0      	; 0x1b16 <node_0_1+0x94>
    1b16:	00 00       	nop
		_delay_ms(500);
		soft_right_2();
    1b18:	0e 94 a5 03 	call	0x74a	; 0x74a <soft_right_2>
    1b1c:	89 e9       	ldi	r24, 0x99	; 153
    1b1e:	99 e5       	ldi	r25, 0x59	; 89
    1b20:	ac e1       	ldi	r26, 0x1C	; 28
    1b22:	81 50       	subi	r24, 0x01	; 1
    1b24:	90 40       	sbci	r25, 0x00	; 0
    1b26:	a0 40       	sbci	r26, 0x00	; 0
    1b28:	e1 f7       	brne	.-8      	; 0x1b22 <node_0_1+0xa0>
    1b2a:	00 00       	nop
		_delay_ms(630);
		//bw_follow_black_line();
		velocity(180,180);
    1b2c:	84 eb       	ldi	r24, 0xB4	; 180
    1b2e:	64 eb       	ldi	r22, 0xB4	; 180
    1b30:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
		//right_degrees(15,1);//10
		stop();
    1b34:	0e 94 21 03 	call	0x642	; 0x642 <stop>
    1b38:	8f ef       	ldi	r24, 0xFF	; 255
    1b3a:	9f ef       	ldi	r25, 0xFF	; 255
    1b3c:	a9 e5       	ldi	r26, 0x59	; 89
    1b3e:	81 50       	subi	r24, 0x01	; 1
    1b40:	90 40       	sbci	r25, 0x00	; 0
    1b42:	a0 40       	sbci	r26, 0x00	; 0
    1b44:	e1 f7       	brne	.-8      	; 0x1b3e <node_0_1+0xbc>
    1b46:	00 c0       	rjmp	.+0      	; 0x1b48 <node_0_1+0xc6>
    1b48:	00 00       	nop
		_delay_ms(2000);
		}		
		if (b_flag==sortedFlag[1])		//place block and go over bridge
    1b4a:	20 91 2c 02 	lds	r18, 0x022C
    1b4e:	30 91 2d 02 	lds	r19, 0x022D
    1b52:	80 91 24 02 	lds	r24, 0x0224
    1b56:	90 91 25 02 	lds	r25, 0x0225
    1b5a:	28 17       	cp	r18, r24
    1b5c:	39 07       	cpc	r19, r25
    1b5e:	81 f4       	brne	.+32     	; 0x1b80 <node_0_1+0xfe>
		{
			buzzer_on();
    1b60:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    1b64:	8f ef       	ldi	r24, 0xFF	; 255
    1b66:	9f ef       	ldi	r25, 0xFF	; 255
    1b68:	a8 e0       	ldi	r26, 0x08	; 8
    1b6a:	81 50       	subi	r24, 0x01	; 1
    1b6c:	90 40       	sbci	r25, 0x00	; 0
    1b6e:	a0 40       	sbci	r26, 0x00	; 0
    1b70:	e1 f7       	brne	.-8      	; 0x1b6a <node_0_1+0xe8>
    1b72:	00 c0       	rjmp	.+0      	; 0x1b74 <node_0_1+0xf2>
    1b74:	00 00       	nop
			_delay_ms(200);
			buzzer_off();
    1b76:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
			place_block();
    1b7a:	0e 94 30 0a 	call	0x1460	; 0x1460 <place_block>
    1b7e:	04 c0       	rjmp	.+8      	; 0x1b88 <node_0_1+0x106>
			//left_degrees(190,0);
			
		}
		else
		{	
			forward_mm(10);						//turn left
    1b80:	8a e0       	ldi	r24, 0x0A	; 10
    1b82:	90 e0       	ldi	r25, 0x00	; 0
    1b84:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
		/*
		left_degrees(85,1);//50/96/90
		fw_follow_black_line();
		*/
	}
	if (flag==1)			//turn left
    1b88:	c1 30       	cpi	r28, 0x01	; 1
    1b8a:	d1 05       	cpc	r29, r1
    1b8c:	81 f4       	brne	.+32     	; 0x1bae <node_0_1+0x12c>
	{
		left();
    1b8e:	0e 94 15 03 	call	0x62a	; 0x62a <left>
    1b92:	a6 e6       	ldi	r26, 0x66	; 102
    1b94:	be e0       	ldi	r27, 0x0E	; 14
    1b96:	11 97       	sbiw	r26, 0x01	; 1
    1b98:	f1 f7       	brne	.-4      	; 0x1b96 <node_0_1+0x114>
    1b9a:	00 00       	nop
		_delay_ms(1);
		left_degrees(80,0);
    1b9c:	80 e5       	ldi	r24, 0x50	; 80
    1b9e:	90 e0       	ldi	r25, 0x00	; 0
    1ba0:	60 e0       	ldi	r22, 0x00	; 0
    1ba2:	70 e0       	ldi	r23, 0x00	; 0
    1ba4:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
		fw_follow_black_line();
    1ba8:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
    1bac:	0b c0       	rjmp	.+22     	; 0x1bc4 <node_0_1+0x142>
	}
	if (flag==2)			//turn right
    1bae:	c2 30       	cpi	r28, 0x02	; 2
    1bb0:	d1 05       	cpc	r29, r1
    1bb2:	41 f4       	brne	.+16     	; 0x1bc4 <node_0_1+0x142>
	{
		right_degrees(67,1);//80
    1bb4:	83 e4       	ldi	r24, 0x43	; 67
    1bb6:	90 e0       	ldi	r25, 0x00	; 0
    1bb8:	61 e0       	ldi	r22, 0x01	; 1
    1bba:	70 e0       	ldi	r23, 0x00	; 0
    1bbc:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		fw_follow_black_line();
    1bc0:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
	}
	
}
    1bc4:	df 91       	pop	r29
    1bc6:	cf 91       	pop	r28
    1bc8:	08 95       	ret

00001bca <node_m1_1>:

void node_m1_1(int flag,int valid) {
    1bca:	cf 93       	push	r28
    1bcc:	df 93       	push	r29
    1bce:	eb 01       	movw	r28, r22
	if (flag == 0) {			//detect flag color,place if color matches
    1bd0:	00 97       	sbiw	r24, 0x00	; 0
    1bd2:	09 f0       	breq	.+2      	; 0x1bd6 <node_m1_1+0xc>
    1bd4:	8e c0       	rjmp	.+284    	; 0x1cf2 <node_m1_1+0x128>
	right_degrees(93,0);//85 110,0
    1bd6:	8d e5       	ldi	r24, 0x5D	; 93
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	60 e0       	ldi	r22, 0x00	; 0
    1bdc:	70 e0       	ldi	r23, 0x00	; 0
    1bde:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
	
	if(valid){
    1be2:	20 97       	sbiw	r28, 0x00	; 0
    1be4:	09 f4       	brne	.+2      	; 0x1be8 <node_m1_1+0x1e>
    1be6:	5f c0       	rjmp	.+190    	; 0x1ca6 <node_m1_1+0xdc>
	//fw_follow_black_line();
	forward_mm(165-50);//165
    1be8:	83 e7       	ldi	r24, 0x73	; 115
    1bea:	90 e0       	ldi	r25, 0x00	; 0
    1bec:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
	rotate_at_flag();
    1bf0:	0e 94 f6 07 	call	0xfec	; 0xfec <rotate_at_flag>
	backward_mm(10);
    1bf4:	8a e0       	ldi	r24, 0x0A	; 10
    1bf6:	90 e0       	ldi	r25, 0x00	; 0
    1bf8:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
	c_flag = detect_color();
    1bfc:	0e 94 00 02 	call	0x400	; 0x400 <detect_color>
    1c00:	90 93 23 02 	sts	0x0223, r25
    1c04:	80 93 22 02 	sts	0x0222, r24
	print_color(c_flag);
    1c08:	0e 94 bb 02 	call	0x576	; 0x576 <print_color>
	
	
	backward_mm(50);
    1c0c:	82 e3       	ldi	r24, 0x32	; 50
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
	stop();
    1c14:	0e 94 21 03 	call	0x642	; 0x642 <stop>
    1c18:	8f ef       	ldi	r24, 0xFF	; 255
    1c1a:	9f e7       	ldi	r25, 0x7F	; 127
    1c1c:	a6 e1       	ldi	r26, 0x16	; 22
    1c1e:	81 50       	subi	r24, 0x01	; 1
    1c20:	90 40       	sbci	r25, 0x00	; 0
    1c22:	a0 40       	sbci	r26, 0x00	; 0
    1c24:	e1 f7       	brne	.-8      	; 0x1c1e <node_m1_1+0x54>
    1c26:	00 c0       	rjmp	.+0      	; 0x1c28 <node_m1_1+0x5e>
    1c28:	00 00       	nop
	_delay_ms(500);
	left_degrees(60,1);
    1c2a:	8c e3       	ldi	r24, 0x3C	; 60
    1c2c:	90 e0       	ldi	r25, 0x00	; 0
    1c2e:	61 e0       	ldi	r22, 0x01	; 1
    1c30:	70 e0       	ldi	r23, 0x00	; 0
    1c32:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
	stop();
    1c36:	0e 94 21 03 	call	0x642	; 0x642 <stop>
    1c3a:	8f ef       	ldi	r24, 0xFF	; 255
    1c3c:	9f e7       	ldi	r25, 0x7F	; 127
    1c3e:	a6 e1       	ldi	r26, 0x16	; 22
    1c40:	81 50       	subi	r24, 0x01	; 1
    1c42:	90 40       	sbci	r25, 0x00	; 0
    1c44:	a0 40       	sbci	r26, 0x00	; 0
    1c46:	e1 f7       	brne	.-8      	; 0x1c40 <node_m1_1+0x76>
    1c48:	00 c0       	rjmp	.+0      	; 0x1c4a <node_m1_1+0x80>
    1c4a:	00 00       	nop
	_delay_ms(500);
	velocity(255,195);
    1c4c:	8f ef       	ldi	r24, 0xFF	; 255
    1c4e:	63 ec       	ldi	r22, 0xC3	; 195
    1c50:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
	backward_mm(150);//170
    1c54:	86 e9       	ldi	r24, 0x96	; 150
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
	
	stop();
    1c5c:	0e 94 21 03 	call	0x642	; 0x642 <stop>
    1c60:	8f ef       	ldi	r24, 0xFF	; 255
    1c62:	9f e7       	ldi	r25, 0x7F	; 127
    1c64:	a6 e1       	ldi	r26, 0x16	; 22
    1c66:	81 50       	subi	r24, 0x01	; 1
    1c68:	90 40       	sbci	r25, 0x00	; 0
    1c6a:	a0 40       	sbci	r26, 0x00	; 0
    1c6c:	e1 f7       	brne	.-8      	; 0x1c66 <node_m1_1+0x9c>
    1c6e:	00 c0       	rjmp	.+0      	; 0x1c70 <node_m1_1+0xa6>
    1c70:	00 00       	nop
	_delay_ms(500);
	soft_right_2();
    1c72:	0e 94 a5 03 	call	0x74a	; 0x74a <soft_right_2>
    1c76:	8f ef       	ldi	r24, 0xFF	; 255
    1c78:	9f eb       	ldi	r25, 0xBF	; 191
    1c7a:	a8 e1       	ldi	r26, 0x18	; 24
    1c7c:	81 50       	subi	r24, 0x01	; 1
    1c7e:	90 40       	sbci	r25, 0x00	; 0
    1c80:	a0 40       	sbci	r26, 0x00	; 0
    1c82:	e1 f7       	brne	.-8      	; 0x1c7c <node_m1_1+0xb2>
    1c84:	00 c0       	rjmp	.+0      	; 0x1c86 <node_m1_1+0xbc>
    1c86:	00 00       	nop
	_delay_ms(550);
	//bw_follow_black_line();
	velocity(180,180);
    1c88:	84 eb       	ldi	r24, 0xB4	; 180
    1c8a:	64 eb       	ldi	r22, 0xB4	; 180
    1c8c:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
	//right_degrees(15,1);//10
	stop();
    1c90:	0e 94 21 03 	call	0x642	; 0x642 <stop>
    1c94:	8f ef       	ldi	r24, 0xFF	; 255
    1c96:	9f ef       	ldi	r25, 0xFF	; 255
    1c98:	a9 e5       	ldi	r26, 0x59	; 89
    1c9a:	81 50       	subi	r24, 0x01	; 1
    1c9c:	90 40       	sbci	r25, 0x00	; 0
    1c9e:	a0 40       	sbci	r26, 0x00	; 0
    1ca0:	e1 f7       	brne	.-8      	; 0x1c9a <node_m1_1+0xd0>
    1ca2:	00 c0       	rjmp	.+0      	; 0x1ca4 <node_m1_1+0xda>
    1ca4:	00 00       	nop
	_delay_ms(2000);
	}	
	if (c_flag == sortedFlag[0]) {
    1ca6:	20 91 2a 02 	lds	r18, 0x022A
    1caa:	30 91 2b 02 	lds	r19, 0x022B
    1cae:	80 91 22 02 	lds	r24, 0x0222
    1cb2:	90 91 23 02 	lds	r25, 0x0223
    1cb6:	28 17       	cp	r18, r24
    1cb8:	39 07       	cpc	r19, r25
    1cba:	51 f4       	brne	.+20     	; 0x1cd0 <node_m1_1+0x106>
		forward_mm(15);
    1cbc:	8f e0       	ldi	r24, 0x0F	; 15
    1cbe:	90 e0       	ldi	r25, 0x00	; 0
    1cc0:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
		place_block();
    1cc4:	0e 94 30 0a 	call	0x1460	; 0x1460 <place_block>
		backward_mm(15);
    1cc8:	8f e0       	ldi	r24, 0x0F	; 15
    1cca:	90 e0       	ldi	r25, 0x00	; 0
    1ccc:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
	}
	backward_mm(35);//20
    1cd0:	83 e2       	ldi	r24, 0x23	; 35
    1cd2:	90 e0       	ldi	r25, 0x00	; 0
    1cd4:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
	right_degrees(100,0);
    1cd8:	84 e6       	ldi	r24, 0x64	; 100
    1cda:	90 e0       	ldi	r25, 0x00	; 0
    1cdc:	60 e0       	ldi	r22, 0x00	; 0
    1cde:	70 e0       	ldi	r23, 0x00	; 0
    1ce0:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
	velocity(150,150);
    1ce4:	86 e9       	ldi	r24, 0x96	; 150
    1ce6:	66 e9       	ldi	r22, 0x96	; 150
    1ce8:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
	fw_follow_black_line();
    1cec:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
    1cf0:	0b c0       	rjmp	.+22     	; 0x1d08 <node_m1_1+0x13e>
} else if (flag == 1) {				//pick weight block
    1cf2:	81 30       	cpi	r24, 0x01	; 1
    1cf4:	91 05       	cpc	r25, r1
    1cf6:	41 f4       	brne	.+16     	; 0x1d08 <node_m1_1+0x13e>

//pick_block();
right_degrees(200,0);
    1cf8:	88 ec       	ldi	r24, 0xC8	; 200
    1cfa:	90 e0       	ldi	r25, 0x00	; 0
    1cfc:	60 e0       	ldi	r22, 0x00	; 0
    1cfe:	70 e0       	ldi	r23, 0x00	; 0
    1d00:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
fw_follow_black_line();
    1d04:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
	}
}
    1d08:	df 91       	pop	r29
    1d0a:	cf 91       	pop	r28
    1d0c:	08 95       	ret

00001d0e <node_1_1>:

int node_1_1(int flag)
{
	if(flag==0)				//turn right and drop weight
    1d0e:	00 97       	sbiw	r24, 0x00	; 0
    1d10:	d9 f4       	brne	.+54     	; 0x1d48 <node_1_1+0x3a>
	{
		velocity(180,180);
    1d12:	84 eb       	ldi	r24, 0xB4	; 180
    1d14:	64 eb       	ldi	r22, 0xB4	; 180
    1d16:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
		right_degrees(100,0);
    1d1a:	84 e6       	ldi	r24, 0x64	; 100
    1d1c:	90 e0       	ldi	r25, 0x00	; 0
    1d1e:	60 e0       	ldi	r22, 0x00	; 0
    1d20:	70 e0       	ldi	r23, 0x00	; 0
    1d22:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		backward_mm(50);
    1d26:	82 e3       	ldi	r24, 0x32	; 50
    1d28:	90 e0       	ldi	r25, 0x00	; 0
    1d2a:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		drop_weight();
    1d2e:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <drop_weight>
		left_degrees(100,0);
    1d32:	84 e6       	ldi	r24, 0x64	; 100
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	60 e0       	ldi	r22, 0x00	; 0
    1d38:	70 e0       	ldi	r23, 0x00	; 0
    1d3a:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
		fw_follow_black_line();
    1d3e:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
		stop();
    1d42:	0e 94 21 03 	call	0x642	; 0x642 <stop>
    1d46:	26 c0       	rjmp	.+76     	; 0x1d94 <node_1_1+0x86>
		//return 1;
	}
	if(flag==1)
    1d48:	81 30       	cpi	r24, 0x01	; 1
    1d4a:	91 05       	cpc	r25, r1
    1d4c:	d9 f4       	brne	.+54     	; 0x1d84 <node_1_1+0x76>
	{
		velocity(180,180);
    1d4e:	84 eb       	ldi	r24, 0xB4	; 180
    1d50:	64 eb       	ldi	r22, 0xB4	; 180
    1d52:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
		left_degrees(100,0);
    1d56:	84 e6       	ldi	r24, 0x64	; 100
    1d58:	90 e0       	ldi	r25, 0x00	; 0
    1d5a:	60 e0       	ldi	r22, 0x00	; 0
    1d5c:	70 e0       	ldi	r23, 0x00	; 0
    1d5e:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
		backward_mm(50);
    1d62:	82 e3       	ldi	r24, 0x32	; 50
    1d64:	90 e0       	ldi	r25, 0x00	; 0
    1d66:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		drop_weight();
    1d6a:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <drop_weight>
		right_degrees(100,0);
    1d6e:	84 e6       	ldi	r24, 0x64	; 100
    1d70:	90 e0       	ldi	r25, 0x00	; 0
    1d72:	60 e0       	ldi	r22, 0x00	; 0
    1d74:	70 e0       	ldi	r23, 0x00	; 0
    1d76:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		stop();
    1d7a:	0e 94 21 03 	call	0x642	; 0x642 <stop>
		return 2;
    1d7e:	22 e0       	ldi	r18, 0x02	; 2
    1d80:	30 e0       	ldi	r19, 0x00	; 0
    1d82:	09 c0       	rjmp	.+18     	; 0x1d96 <node_1_1+0x88>
	}
	if(flag==2)					//go straight
    1d84:	82 30       	cpi	r24, 0x02	; 2
    1d86:	91 05       	cpc	r25, r1
    1d88:	29 f4       	brne	.+10     	; 0x1d94 <node_1_1+0x86>
	{
		fw_follow_black_line();
    1d8a:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
		return 1;
    1d8e:	21 e0       	ldi	r18, 0x01	; 1
    1d90:	30 e0       	ldi	r19, 0x00	; 0
    1d92:	01 c0       	rjmp	.+2      	; 0x1d96 <node_1_1+0x88>
    1d94:	08 95       	ret
	}
}
    1d96:	82 2f       	mov	r24, r18
    1d98:	93 2f       	mov	r25, r19
    1d9a:	08 95       	ret

00001d9c <node_2_1>:

void node_2_1(int flag, int angle)
{
	if(flag==0)						//turn left and place block
    1d9c:	00 97       	sbiw	r24, 0x00	; 0
    1d9e:	a9 f4       	brne	.+42     	; 0x1dca <node_2_1+0x2e>
	{
		//fw_follow_black_line();
		velocity(180,180);
    1da0:	84 eb       	ldi	r24, 0xB4	; 180
    1da2:	64 eb       	ldi	r22, 0xB4	; 180
    1da4:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
		left_degrees(128,0);
    1da8:	80 e8       	ldi	r24, 0x80	; 128
    1daa:	90 e0       	ldi	r25, 0x00	; 0
    1dac:	60 e0       	ldi	r22, 0x00	; 0
    1dae:	70 e0       	ldi	r23, 0x00	; 0
    1db0:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
		backward_mm(50);
    1db4:	82 e3       	ldi	r24, 0x32	; 50
    1db6:	90 e0       	ldi	r25, 0x00	; 0
    1db8:	0e 94 39 07 	call	0xe72	; 0xe72 <backward_mm>
		place_block();
    1dbc:	0e 94 30 0a 	call	0x1460	; 0x1460 <place_block>
		//right_degrees(100,0);
		velocity(180,225);
    1dc0:	84 eb       	ldi	r24, 0xB4	; 180
    1dc2:	61 ee       	ldi	r22, 0xE1	; 225
    1dc4:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
    1dc8:	08 95       	ret
		
		//backward_mm(20);
		//left_degrees(95,0);	--uncomment for generalized
		//fw_follow_black_line();
	}
	if(flag==1)					//pick weight block
    1dca:	81 30       	cpi	r24, 0x01	; 1
    1dcc:	91 05       	cpc	r25, r1
    1dce:	59 f4       	brne	.+22     	; 0x1de6 <node_2_1+0x4a>
	{
		//fw_follow_black_line();
		pick_block(angle);
    1dd0:	cb 01       	movw	r24, r22
    1dd2:	0e 94 9e 0a 	call	0x153c	; 0x153c <pick_block>
		right_degrees(190,0);
    1dd6:	8e eb       	ldi	r24, 0xBE	; 190
    1dd8:	90 e0       	ldi	r25, 0x00	; 0
    1dda:	60 e0       	ldi	r22, 0x00	; 0
    1ddc:	70 e0       	ldi	r23, 0x00	; 0
    1dde:	0e 94 c4 07 	call	0xf88	; 0xf88 <right_degrees>
		fw_follow_black_line();
    1de2:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
    1de6:	08 95       	ret

00001de8 <detect_third_waste>:
#include "servo.h"
#include "node.h"
//#include "velocity.h"

int detect_third_waste(){
	if (sortedFlag[0] == 1 && sortedFlag[1] == 2) {
    1de8:	80 91 2a 02 	lds	r24, 0x022A
    1dec:	90 91 2b 02 	lds	r25, 0x022B
    1df0:	81 30       	cpi	r24, 0x01	; 1
    1df2:	91 05       	cpc	r25, r1
    1df4:	51 f4       	brne	.+20     	; 0x1e0a <detect_third_waste+0x22>
    1df6:	80 91 2c 02 	lds	r24, 0x022C
    1dfa:	90 91 2d 02 	lds	r25, 0x022D
    1dfe:	82 30       	cpi	r24, 0x02	; 2
    1e00:	91 05       	cpc	r25, r1
    1e02:	81 f0       	breq	.+32     	; 0x1e24 <detect_third_waste+0x3c>
		return 3;
	} else if (sortedFlag[0] == 2 && sortedFlag[1] == 3) {
		return 1;
	} else 
		return 2;	
    1e04:	82 e0       	ldi	r24, 0x02	; 2
    1e06:	90 e0       	ldi	r25, 0x00	; 0
    1e08:	08 95       	ret
//#include "velocity.h"

int detect_third_waste(){
	if (sortedFlag[0] == 1 && sortedFlag[1] == 2) {
		return 3;
	} else if (sortedFlag[0] == 2 && sortedFlag[1] == 3) {
    1e0a:	82 30       	cpi	r24, 0x02	; 2
    1e0c:	91 05       	cpc	r25, r1
    1e0e:	69 f4       	brne	.+26     	; 0x1e2a <detect_third_waste+0x42>
    1e10:	80 91 2c 02 	lds	r24, 0x022C
    1e14:	90 91 2d 02 	lds	r25, 0x022D
    1e18:	83 30       	cpi	r24, 0x03	; 3
    1e1a:	91 05       	cpc	r25, r1
    1e1c:	49 f0       	breq	.+18     	; 0x1e30 <detect_third_waste+0x48>
		return 1;
	} else 
		return 2;	
    1e1e:	82 e0       	ldi	r24, 0x02	; 2
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	08 95       	ret
#include "node.h"
//#include "velocity.h"

int detect_third_waste(){
	if (sortedFlag[0] == 1 && sortedFlag[1] == 2) {
		return 3;
    1e24:	83 e0       	ldi	r24, 0x03	; 3
    1e26:	90 e0       	ldi	r25, 0x00	; 0
    1e28:	08 95       	ret
	} else if (sortedFlag[0] == 2 && sortedFlag[1] == 3) {
		return 1;
	} else 
		return 2;	
    1e2a:	82 e0       	ldi	r24, 0x02	; 2
    1e2c:	90 e0       	ldi	r25, 0x00	; 0
    1e2e:	08 95       	ret

int detect_third_waste(){
	if (sortedFlag[0] == 1 && sortedFlag[1] == 2) {
		return 3;
	} else if (sortedFlag[0] == 2 && sortedFlag[1] == 3) {
		return 1;
    1e30:	81 e0       	ldi	r24, 0x01	; 1
    1e32:	90 e0       	ldi	r25, 0x00	; 0
	} else 
		return 2;	
}
    1e34:	08 95       	ret

00001e36 <main>:


int main(void)
{
	init_devices_color();
    1e36:	0e 94 1a 01 	call	0x234	; 0x234 <init_devices_color>
	lcd_set_4bit();
    1e3a:	0e 94 56 08 	call	0x10ac	; 0x10ac <lcd_set_4bit>
	color_sensor_scaling();
    1e3e:	0e 94 2d 01 	call	0x25a	; 0x25a <color_sensor_scaling>
	init_devices();
    1e42:	0e 94 71 06 	call	0xce2	; 0xce2 <init_devices>
	lcd_port_config ();
    1e46:	0e 94 ac 00 	call	0x158	; 0x158 <lcd_port_config>
	lcd_init();
    1e4a:	0e 94 de 08 	call	0x11bc	; 0x11bc <lcd_init>
	buzzer_pin_config();
    1e4e:	0e 94 ba 09 	call	0x1374	; 0x1374 <buzzer_pin_config>
	motion_pin_config ();
    1e52:	0e 94 db 02 	call	0x5b6	; 0x5b6 <motion_pin_config>
	timer5_init();
    1e56:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <timer5_init>
	adc_pin_config ();
    1e5a:	0e 94 b3 00 	call	0x166	; 0x166 <adc_pin_config>
	adc_init();
    1e5e:	0e 94 ba 00 	call	0x174	; 0x174 <adc_init>
	servo1_pin_config();
    1e62:	0e 94 bd 09 	call	0x137a	; 0x137a <servo1_pin_config>
	servo2_pin_config();
    1e66:	0e 94 c0 09 	call	0x1380	; 0x1380 <servo2_pin_config>
	timer1_init();
    1e6a:	0e 94 cd 09 	call	0x139a	; 0x139a <timer1_init>
    1e6e:	8f ef       	ldi	r24, 0xFF	; 255
    1e70:	9f e7       	ldi	r25, 0x7F	; 127
    1e72:	a4 e0       	ldi	r26, 0x04	; 4
    1e74:	81 50       	subi	r24, 0x01	; 1
    1e76:	90 40       	sbci	r25, 0x00	; 0
    1e78:	a0 40       	sbci	r26, 0x00	; 0
    1e7a:	e1 f7       	brne	.-8      	; 0x1e74 <main+0x3e>
    1e7c:	00 c0       	rjmp	.+0      	; 0x1e7e <main+0x48>
    1e7e:	00 00       	nop
	fw_follow_black_line();*/
	
	_delay_ms(100);
	/************************FIRST RUN*******************************/

	node0_0(4,90);		//initial 180 degrees turn
    1e80:	84 e0       	ldi	r24, 0x04	; 4
    1e82:	90 e0       	ldi	r25, 0x00	; 0
    1e84:	6a e5       	ldi	r22, 0x5A	; 90
    1e86:	70 e0       	ldi	r23, 0x00	; 0
    1e88:	0e 94 b4 0b 	call	0x1768	; 0x1768 <node0_0>
	node0_0(1,90);
    1e8c:	81 e0       	ldi	r24, 0x01	; 1
    1e8e:	90 e0       	ldi	r25, 0x00	; 0
    1e90:	6a e5       	ldi	r22, 0x5A	; 90
    1e92:	70 e0       	ldi	r23, 0x00	; 0
    1e94:	0e 94 b4 0b 	call	0x1768	; 0x1768 <node0_0>
	node_m1_0(2);		//goes forward
    1e98:	82 e0       	ldi	r24, 0x02	; 2
    1e9a:	90 e0       	ldi	r25, 0x00	; 0
    1e9c:	0e 94 6d 0c 	call	0x18da	; 0x18da <node_m1_0>
	node_m2_0(1);	
    1ea0:	81 e0       	ldi	r24, 0x01	; 1
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	0e 94 c6 0c 	call	0x198c	; 0x198c <node_m2_0>
	node_m1_0(3);
    1ea8:	83 e0       	ldi	r24, 0x03	; 3
    1eaa:	90 e0       	ldi	r25, 0x00	; 0
    1eac:	0e 94 6d 0c 	call	0x18da	; 0x18da <node_m1_0>
	
	forward_mm(30);		
    1eb0:	8e e1       	ldi	r24, 0x1E	; 30
    1eb2:	90 e0       	ldi	r25, 0x00	; 0
    1eb4:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <forward_mm>
	
	node0_0(0,90);
    1eb8:	80 e0       	ldi	r24, 0x00	; 0
    1eba:	90 e0       	ldi	r25, 0x00	; 0
    1ebc:	6a e5       	ldi	r22, 0x5A	; 90
    1ebe:	70 e0       	ldi	r23, 0x00	; 0
    1ec0:	0e 94 b4 0b 	call	0x1768	; 0x1768 <node0_0>
	velocity(180,180);
    1ec4:	84 eb       	ldi	r24, 0xB4	; 180
    1ec6:	64 eb       	ldi	r22, 0xB4	; 180
    1ec8:	0e 94 a9 03 	call	0x752	; 0x752 <velocity>
	//fw_follow_black_line();
	node_0_1(0,1);
    1ecc:	80 e0       	ldi	r24, 0x00	; 0
    1ece:	90 e0       	ldi	r25, 0x00	; 0
    1ed0:	61 e0       	ldi	r22, 0x01	; 1
    1ed2:	70 e0       	ldi	r23, 0x00	; 0
    1ed4:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <node_0_1>
	node_0_1(1,0);
    1ed8:	81 e0       	ldi	r24, 0x01	; 1
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	60 e0       	ldi	r22, 0x00	; 0
    1ede:	70 e0       	ldi	r23, 0x00	; 0
    1ee0:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <node_0_1>
	node_m1_1(0,1);
    1ee4:	80 e0       	ldi	r24, 0x00	; 0
    1ee6:	90 e0       	ldi	r25, 0x00	; 0
    1ee8:	61 e0       	ldi	r22, 0x01	; 1
    1eea:	70 e0       	ldi	r23, 0x00	; 0
    1eec:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <node_m1_1>
	node_0_1(2,0);			//comes back
    1ef0:	82 e0       	ldi	r24, 0x02	; 2
    1ef2:	90 e0       	ldi	r25, 0x00	; 0
    1ef4:	60 e0       	ldi	r22, 0x00	; 0
    1ef6:	70 e0       	ldi	r23, 0x00	; 0
    1ef8:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <node_0_1>
	
	/************************SECOND RUN**********************************/
	
	//fw_follow_black_line();
		
		node0_0(5,90);		
    1efc:	85 e0       	ldi	r24, 0x05	; 5
    1efe:	90 e0       	ldi	r25, 0x00	; 0
    1f00:	6a e5       	ldi	r22, 0x5A	; 90
    1f02:	70 e0       	ldi	r23, 0x00	; 0
    1f04:	0e 94 b4 0b 	call	0x1768	; 0x1768 <node0_0>
		//node0_0(1,90);
		node_m1_0(2);		//goes forward
    1f08:	82 e0       	ldi	r24, 0x02	; 2
    1f0a:	90 e0       	ldi	r25, 0x00	; 0
    1f0c:	0e 94 6d 0c 	call	0x18da	; 0x18da <node_m1_0>
		node_m2_0(1);
    1f10:	81 e0       	ldi	r24, 0x01	; 1
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	0e 94 c6 0c 	call	0x198c	; 0x198c <node_m2_0>
		node_m1_0(3);
    1f18:	83 e0       	ldi	r24, 0x03	; 3
    1f1a:	90 e0       	ldi	r25, 0x00	; 0
    1f1c:	0e 94 6d 0c 	call	0x18da	; 0x18da <node_m1_0>
		node0_0(0,90);
    1f20:	80 e0       	ldi	r24, 0x00	; 0
    1f22:	90 e0       	ldi	r25, 0x00	; 0
    1f24:	6a e5       	ldi	r22, 0x5A	; 90
    1f26:	70 e0       	ldi	r23, 0x00	; 0
    1f28:	0e 94 b4 0b 	call	0x1768	; 0x1768 <node0_0>
	
		if(sortedFlag[1] == b_flag){
    1f2c:	80 91 2c 02 	lds	r24, 0x022C
    1f30:	90 91 2d 02 	lds	r25, 0x022D
    1f34:	20 91 24 02 	lds	r18, 0x0224
    1f38:	30 91 25 02 	lds	r19, 0x0225
    1f3c:	82 17       	cp	r24, r18
    1f3e:	93 07       	cpc	r25, r19
    1f40:	e1 f4       	brne	.+56     	; 0x1f7a <main+0x144>
			buzzer_on();
    1f42:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    1f46:	8f ef       	ldi	r24, 0xFF	; 255
    1f48:	9f ef       	ldi	r25, 0xFF	; 255
    1f4a:	a8 e0       	ldi	r26, 0x08	; 8
    1f4c:	81 50       	subi	r24, 0x01	; 1
    1f4e:	90 40       	sbci	r25, 0x00	; 0
    1f50:	a0 40       	sbci	r26, 0x00	; 0
    1f52:	e1 f7       	brne	.-8      	; 0x1f4c <main+0x116>
    1f54:	00 c0       	rjmp	.+0      	; 0x1f56 <main+0x120>
    1f56:	00 00       	nop
			_delay_ms(200);
			buzzer_off();
    1f58:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
			node_0_1(0,0);
    1f5c:	80 e0       	ldi	r24, 0x00	; 0
    1f5e:	90 e0       	ldi	r25, 0x00	; 0
    1f60:	60 e0       	ldi	r22, 0x00	; 0
    1f62:	70 e0       	ldi	r23, 0x00	; 0
    1f64:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <node_0_1>
			left_degrees(176,1);
    1f68:	80 eb       	ldi	r24, 0xB0	; 176
    1f6a:	90 e0       	ldi	r25, 0x00	; 0
    1f6c:	61 e0       	ldi	r22, 0x01	; 1
    1f6e:	70 e0       	ldi	r23, 0x00	; 0
    1f70:	0e 94 92 07 	call	0xf24	; 0xf24 <left_degrees>
			fw_follow_black_line();	
    1f74:	0e 94 37 06 	call	0xc6e	; 0xc6e <fw_follow_black_line>
    1f78:	30 c0       	rjmp	.+96     	; 0x1fda <main+0x1a4>
		}
		else if(sortedFlag[1] == c_flag){
    1f7a:	20 91 22 02 	lds	r18, 0x0222
    1f7e:	30 91 23 02 	lds	r19, 0x0223
    1f82:	82 17       	cp	r24, r18
    1f84:	93 07       	cpc	r25, r19
    1f86:	99 f4       	brne	.+38     	; 0x1fae <main+0x178>
			node_0_1(1,0);
    1f88:	81 e0       	ldi	r24, 0x01	; 1
    1f8a:	90 e0       	ldi	r25, 0x00	; 0
    1f8c:	60 e0       	ldi	r22, 0x00	; 0
    1f8e:	70 e0       	ldi	r23, 0x00	; 0
    1f90:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <node_0_1>
			node_m1_1(0,0);
    1f94:	80 e0       	ldi	r24, 0x00	; 0
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	60 e0       	ldi	r22, 0x00	; 0
    1f9a:	70 e0       	ldi	r23, 0x00	; 0
    1f9c:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <node_m1_1>
			node_0_1(2,0);
    1fa0:	82 e0       	ldi	r24, 0x02	; 2
    1fa2:	90 e0       	ldi	r25, 0x00	; 0
    1fa4:	60 e0       	ldi	r22, 0x00	; 0
    1fa6:	70 e0       	ldi	r23, 0x00	; 0
    1fa8:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <node_0_1>
    1fac:	16 c0       	rjmp	.+44     	; 0x1fda <main+0x1a4>
		}
		else{
			node_0_1(2,0);
    1fae:	82 e0       	ldi	r24, 0x02	; 2
    1fb0:	90 e0       	ldi	r25, 0x00	; 0
    1fb2:	60 e0       	ldi	r22, 0x00	; 0
    1fb4:	70 e0       	ldi	r23, 0x00	; 0
    1fb6:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <node_0_1>
			node_1_1(2);
    1fba:	82 e0       	ldi	r24, 0x02	; 2
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
    1fbe:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <node_1_1>
			node_2_1(0,90);
    1fc2:	80 e0       	ldi	r24, 0x00	; 0
    1fc4:	90 e0       	ldi	r25, 0x00	; 0
    1fc6:	6a e5       	ldi	r22, 0x5A	; 90
    1fc8:	70 e0       	ldi	r23, 0x00	; 0
    1fca:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <node_2_1>
			node_0_1(2,0);			//comes back
    1fce:	82 e0       	ldi	r24, 0x02	; 2
    1fd0:	90 e0       	ldi	r25, 0x00	; 0
    1fd2:	60 e0       	ldi	r22, 0x00	; 0
    1fd4:	70 e0       	ldi	r23, 0x00	; 0
    1fd6:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <node_0_1>
	//node_0_1(2);			//comes back
	
	/**********************************************************************************/
	/************************THIRD RUN**********************************************/
	//fw_follow_black_line();
	node0_0(6,90);
    1fda:	86 e0       	ldi	r24, 0x06	; 6
    1fdc:	90 e0       	ldi	r25, 0x00	; 0
    1fde:	6a e5       	ldi	r22, 0x5A	; 90
    1fe0:	70 e0       	ldi	r23, 0x00	; 0
    1fe2:	0e 94 b4 0b 	call	0x1768	; 0x1768 <node0_0>
	
		if(detect_third_waste() == b_flag){
    1fe6:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <detect_third_waste>
    1fea:	20 91 24 02 	lds	r18, 0x0224
    1fee:	30 91 25 02 	lds	r19, 0x0225
    1ff2:	82 17       	cp	r24, r18
    1ff4:	93 07       	cpc	r25, r19
    1ff6:	a1 f4       	brne	.+40     	; 0x2020 <main+0x1ea>
			buzzer_on();
    1ff8:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    1ffc:	8f ef       	ldi	r24, 0xFF	; 255
    1ffe:	9f ef       	ldi	r25, 0xFF	; 255
    2000:	a8 e0       	ldi	r26, 0x08	; 8
    2002:	81 50       	subi	r24, 0x01	; 1
    2004:	90 40       	sbci	r25, 0x00	; 0
    2006:	a0 40       	sbci	r26, 0x00	; 0
    2008:	e1 f7       	brne	.-8      	; 0x2002 <main+0x1cc>
    200a:	00 c0       	rjmp	.+0      	; 0x200c <main+0x1d6>
    200c:	00 00       	nop
			_delay_ms(200);
			buzzer_off();
    200e:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
			node_0_1(0,0);
    2012:	80 e0       	ldi	r24, 0x00	; 0
    2014:	90 e0       	ldi	r25, 0x00	; 0
    2016:	60 e0       	ldi	r22, 0x00	; 0
    2018:	70 e0       	ldi	r23, 0x00	; 0
    201a:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <node_0_1>
    201e:	24 c0       	rjmp	.+72     	; 0x2068 <main+0x232>
			//left_degrees(160,1);
			//fw_follow_black_line();
		}
		else if(detect_third_waste() == c_flag){
    2020:	20 91 22 02 	lds	r18, 0x0222
    2024:	30 91 23 02 	lds	r19, 0x0223
    2028:	82 17       	cp	r24, r18
    202a:	93 07       	cpc	r25, r19
    202c:	69 f4       	brne	.+26     	; 0x2048 <main+0x212>
			node_0_1(1,0);
    202e:	81 e0       	ldi	r24, 0x01	; 1
    2030:	90 e0       	ldi	r25, 0x00	; 0
    2032:	60 e0       	ldi	r22, 0x00	; 0
    2034:	70 e0       	ldi	r23, 0x00	; 0
    2036:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <node_0_1>
			node_m1_1(0,0);
    203a:	80 e0       	ldi	r24, 0x00	; 0
    203c:	90 e0       	ldi	r25, 0x00	; 0
    203e:	60 e0       	ldi	r22, 0x00	; 0
    2040:	70 e0       	ldi	r23, 0x00	; 0
    2042:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <node_m1_1>
    2046:	10 c0       	rjmp	.+32     	; 0x2068 <main+0x232>
			//node_0_1(2,0);
		}
		else{
			node_0_1(2,0);
    2048:	82 e0       	ldi	r24, 0x02	; 2
    204a:	90 e0       	ldi	r25, 0x00	; 0
    204c:	60 e0       	ldi	r22, 0x00	; 0
    204e:	70 e0       	ldi	r23, 0x00	; 0
    2050:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <node_0_1>
			node_1_1(2);
    2054:	82 e0       	ldi	r24, 0x02	; 2
    2056:	90 e0       	ldi	r25, 0x00	; 0
    2058:	0e 94 87 0e 	call	0x1d0e	; 0x1d0e <node_1_1>
			node_2_1(0,90);
    205c:	80 e0       	ldi	r24, 0x00	; 0
    205e:	90 e0       	ldi	r25, 0x00	; 0
    2060:	6a e5       	ldi	r22, 0x5A	; 90
    2062:	70 e0       	ldi	r23, 0x00	; 0
    2064:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <node_2_1>
			//node_0_1(2,0);			//comes back
		}
		buzzer_on();
    2068:	0e 94 a7 00 	call	0x14e	; 0x14e <buzzer_on>
    206c:	8f ef       	ldi	r24, 0xFF	; 255
    206e:	9f ef       	ldi	r25, 0xFF	; 255
    2070:	a0 ee       	ldi	r26, 0xE0	; 224
    2072:	b0 e0       	ldi	r27, 0x00	; 0
    2074:	81 50       	subi	r24, 0x01	; 1
    2076:	90 40       	sbci	r25, 0x00	; 0
    2078:	a0 40       	sbci	r26, 0x00	; 0
    207a:	b0 40       	sbci	r27, 0x00	; 0
    207c:	d9 f7       	brne	.-10     	; 0x2074 <main+0x23e>
    207e:	00 c0       	rjmp	.+0      	; 0x2080 <main+0x24a>
    2080:	00 00       	nop
		_delay_ms(6000);
		buzzer_off();
    2082:	0e 94 aa 00 	call	0x154	; 0x154 <buzzer_off>
	
	/**********************************************************************************/
	return 0;
    2086:	80 e0       	ldi	r24, 0x00	; 0
    2088:	90 e0       	ldi	r25, 0x00	; 0
    208a:	08 95       	ret

0000208c <__subsf3>:
    208c:	50 58       	subi	r21, 0x80	; 128

0000208e <__addsf3>:
    208e:	bb 27       	eor	r27, r27
    2090:	aa 27       	eor	r26, r26
    2092:	0e d0       	rcall	.+28     	; 0x20b0 <__addsf3x>
    2094:	75 c1       	rjmp	.+746    	; 0x2380 <__fp_round>
    2096:	66 d1       	rcall	.+716    	; 0x2364 <__fp_pscA>
    2098:	30 f0       	brcs	.+12     	; 0x20a6 <__addsf3+0x18>
    209a:	6b d1       	rcall	.+726    	; 0x2372 <__fp_pscB>
    209c:	20 f0       	brcs	.+8      	; 0x20a6 <__addsf3+0x18>
    209e:	31 f4       	brne	.+12     	; 0x20ac <__addsf3+0x1e>
    20a0:	9f 3f       	cpi	r25, 0xFF	; 255
    20a2:	11 f4       	brne	.+4      	; 0x20a8 <__addsf3+0x1a>
    20a4:	1e f4       	brtc	.+6      	; 0x20ac <__addsf3+0x1e>
    20a6:	5b c1       	rjmp	.+694    	; 0x235e <__fp_nan>
    20a8:	0e f4       	brtc	.+2      	; 0x20ac <__addsf3+0x1e>
    20aa:	e0 95       	com	r30
    20ac:	e7 fb       	bst	r30, 7
    20ae:	51 c1       	rjmp	.+674    	; 0x2352 <__fp_inf>

000020b0 <__addsf3x>:
    20b0:	e9 2f       	mov	r30, r25
    20b2:	77 d1       	rcall	.+750    	; 0x23a2 <__fp_split3>
    20b4:	80 f3       	brcs	.-32     	; 0x2096 <__addsf3+0x8>
    20b6:	ba 17       	cp	r27, r26
    20b8:	62 07       	cpc	r22, r18
    20ba:	73 07       	cpc	r23, r19
    20bc:	84 07       	cpc	r24, r20
    20be:	95 07       	cpc	r25, r21
    20c0:	18 f0       	brcs	.+6      	; 0x20c8 <__addsf3x+0x18>
    20c2:	71 f4       	brne	.+28     	; 0x20e0 <__addsf3x+0x30>
    20c4:	9e f5       	brtc	.+102    	; 0x212c <__addsf3x+0x7c>
    20c6:	8f c1       	rjmp	.+798    	; 0x23e6 <__fp_zero>
    20c8:	0e f4       	brtc	.+2      	; 0x20cc <__addsf3x+0x1c>
    20ca:	e0 95       	com	r30
    20cc:	0b 2e       	mov	r0, r27
    20ce:	ba 2f       	mov	r27, r26
    20d0:	a0 2d       	mov	r26, r0
    20d2:	0b 01       	movw	r0, r22
    20d4:	b9 01       	movw	r22, r18
    20d6:	90 01       	movw	r18, r0
    20d8:	0c 01       	movw	r0, r24
    20da:	ca 01       	movw	r24, r20
    20dc:	a0 01       	movw	r20, r0
    20de:	11 24       	eor	r1, r1
    20e0:	ff 27       	eor	r31, r31
    20e2:	59 1b       	sub	r21, r25
    20e4:	99 f0       	breq	.+38     	; 0x210c <__addsf3x+0x5c>
    20e6:	59 3f       	cpi	r21, 0xF9	; 249
    20e8:	50 f4       	brcc	.+20     	; 0x20fe <__addsf3x+0x4e>
    20ea:	50 3e       	cpi	r21, 0xE0	; 224
    20ec:	68 f1       	brcs	.+90     	; 0x2148 <__addsf3x+0x98>
    20ee:	1a 16       	cp	r1, r26
    20f0:	f0 40       	sbci	r31, 0x00	; 0
    20f2:	a2 2f       	mov	r26, r18
    20f4:	23 2f       	mov	r18, r19
    20f6:	34 2f       	mov	r19, r20
    20f8:	44 27       	eor	r20, r20
    20fa:	58 5f       	subi	r21, 0xF8	; 248
    20fc:	f3 cf       	rjmp	.-26     	; 0x20e4 <__addsf3x+0x34>
    20fe:	46 95       	lsr	r20
    2100:	37 95       	ror	r19
    2102:	27 95       	ror	r18
    2104:	a7 95       	ror	r26
    2106:	f0 40       	sbci	r31, 0x00	; 0
    2108:	53 95       	inc	r21
    210a:	c9 f7       	brne	.-14     	; 0x20fe <__addsf3x+0x4e>
    210c:	7e f4       	brtc	.+30     	; 0x212c <__addsf3x+0x7c>
    210e:	1f 16       	cp	r1, r31
    2110:	ba 0b       	sbc	r27, r26
    2112:	62 0b       	sbc	r22, r18
    2114:	73 0b       	sbc	r23, r19
    2116:	84 0b       	sbc	r24, r20
    2118:	ba f0       	brmi	.+46     	; 0x2148 <__addsf3x+0x98>
    211a:	91 50       	subi	r25, 0x01	; 1
    211c:	a1 f0       	breq	.+40     	; 0x2146 <__addsf3x+0x96>
    211e:	ff 0f       	add	r31, r31
    2120:	bb 1f       	adc	r27, r27
    2122:	66 1f       	adc	r22, r22
    2124:	77 1f       	adc	r23, r23
    2126:	88 1f       	adc	r24, r24
    2128:	c2 f7       	brpl	.-16     	; 0x211a <__addsf3x+0x6a>
    212a:	0e c0       	rjmp	.+28     	; 0x2148 <__addsf3x+0x98>
    212c:	ba 0f       	add	r27, r26
    212e:	62 1f       	adc	r22, r18
    2130:	73 1f       	adc	r23, r19
    2132:	84 1f       	adc	r24, r20
    2134:	48 f4       	brcc	.+18     	; 0x2148 <__addsf3x+0x98>
    2136:	87 95       	ror	r24
    2138:	77 95       	ror	r23
    213a:	67 95       	ror	r22
    213c:	b7 95       	ror	r27
    213e:	f7 95       	ror	r31
    2140:	9e 3f       	cpi	r25, 0xFE	; 254
    2142:	08 f0       	brcs	.+2      	; 0x2146 <__addsf3x+0x96>
    2144:	b3 cf       	rjmp	.-154    	; 0x20ac <__addsf3+0x1e>
    2146:	93 95       	inc	r25
    2148:	88 0f       	add	r24, r24
    214a:	08 f0       	brcs	.+2      	; 0x214e <__addsf3x+0x9e>
    214c:	99 27       	eor	r25, r25
    214e:	ee 0f       	add	r30, r30
    2150:	97 95       	ror	r25
    2152:	87 95       	ror	r24
    2154:	08 95       	ret

00002156 <__cmpsf2>:
    2156:	d9 d0       	rcall	.+434    	; 0x230a <__fp_cmp>
    2158:	08 f4       	brcc	.+2      	; 0x215c <__cmpsf2+0x6>
    215a:	81 e0       	ldi	r24, 0x01	; 1
    215c:	08 95       	ret

0000215e <__divsf3>:
    215e:	0c d0       	rcall	.+24     	; 0x2178 <__divsf3x>
    2160:	0f c1       	rjmp	.+542    	; 0x2380 <__fp_round>
    2162:	07 d1       	rcall	.+526    	; 0x2372 <__fp_pscB>
    2164:	40 f0       	brcs	.+16     	; 0x2176 <__divsf3+0x18>
    2166:	fe d0       	rcall	.+508    	; 0x2364 <__fp_pscA>
    2168:	30 f0       	brcs	.+12     	; 0x2176 <__divsf3+0x18>
    216a:	21 f4       	brne	.+8      	; 0x2174 <__divsf3+0x16>
    216c:	5f 3f       	cpi	r21, 0xFF	; 255
    216e:	19 f0       	breq	.+6      	; 0x2176 <__divsf3+0x18>
    2170:	f0 c0       	rjmp	.+480    	; 0x2352 <__fp_inf>
    2172:	51 11       	cpse	r21, r1
    2174:	39 c1       	rjmp	.+626    	; 0x23e8 <__fp_szero>
    2176:	f3 c0       	rjmp	.+486    	; 0x235e <__fp_nan>

00002178 <__divsf3x>:
    2178:	14 d1       	rcall	.+552    	; 0x23a2 <__fp_split3>
    217a:	98 f3       	brcs	.-26     	; 0x2162 <__divsf3+0x4>

0000217c <__divsf3_pse>:
    217c:	99 23       	and	r25, r25
    217e:	c9 f3       	breq	.-14     	; 0x2172 <__divsf3+0x14>
    2180:	55 23       	and	r21, r21
    2182:	b1 f3       	breq	.-20     	; 0x2170 <__divsf3+0x12>
    2184:	95 1b       	sub	r25, r21
    2186:	55 0b       	sbc	r21, r21
    2188:	bb 27       	eor	r27, r27
    218a:	aa 27       	eor	r26, r26
    218c:	62 17       	cp	r22, r18
    218e:	73 07       	cpc	r23, r19
    2190:	84 07       	cpc	r24, r20
    2192:	38 f0       	brcs	.+14     	; 0x21a2 <__divsf3_pse+0x26>
    2194:	9f 5f       	subi	r25, 0xFF	; 255
    2196:	5f 4f       	sbci	r21, 0xFF	; 255
    2198:	22 0f       	add	r18, r18
    219a:	33 1f       	adc	r19, r19
    219c:	44 1f       	adc	r20, r20
    219e:	aa 1f       	adc	r26, r26
    21a0:	a9 f3       	breq	.-22     	; 0x218c <__divsf3_pse+0x10>
    21a2:	33 d0       	rcall	.+102    	; 0x220a <__stack+0xb>
    21a4:	0e 2e       	mov	r0, r30
    21a6:	3a f0       	brmi	.+14     	; 0x21b6 <__divsf3_pse+0x3a>
    21a8:	e0 e8       	ldi	r30, 0x80	; 128
    21aa:	30 d0       	rcall	.+96     	; 0x220c <__stack+0xd>
    21ac:	91 50       	subi	r25, 0x01	; 1
    21ae:	50 40       	sbci	r21, 0x00	; 0
    21b0:	e6 95       	lsr	r30
    21b2:	00 1c       	adc	r0, r0
    21b4:	ca f7       	brpl	.-14     	; 0x21a8 <__divsf3_pse+0x2c>
    21b6:	29 d0       	rcall	.+82     	; 0x220a <__stack+0xb>
    21b8:	fe 2f       	mov	r31, r30
    21ba:	27 d0       	rcall	.+78     	; 0x220a <__stack+0xb>
    21bc:	66 0f       	add	r22, r22
    21be:	77 1f       	adc	r23, r23
    21c0:	88 1f       	adc	r24, r24
    21c2:	bb 1f       	adc	r27, r27
    21c4:	26 17       	cp	r18, r22
    21c6:	37 07       	cpc	r19, r23
    21c8:	48 07       	cpc	r20, r24
    21ca:	ab 07       	cpc	r26, r27
    21cc:	b0 e8       	ldi	r27, 0x80	; 128
    21ce:	09 f0       	breq	.+2      	; 0x21d2 <__divsf3_pse+0x56>
    21d0:	bb 0b       	sbc	r27, r27
    21d2:	80 2d       	mov	r24, r0
    21d4:	bf 01       	movw	r22, r30
    21d6:	ff 27       	eor	r31, r31
    21d8:	93 58       	subi	r25, 0x83	; 131
    21da:	5f 4f       	sbci	r21, 0xFF	; 255
    21dc:	2a f0       	brmi	.+10     	; 0x21e8 <__divsf3_pse+0x6c>
    21de:	9e 3f       	cpi	r25, 0xFE	; 254
    21e0:	51 05       	cpc	r21, r1
    21e2:	68 f0       	brcs	.+26     	; 0x21fe <__divsf3_pse+0x82>
    21e4:	b6 c0       	rjmp	.+364    	; 0x2352 <__fp_inf>
    21e6:	00 c1       	rjmp	.+512    	; 0x23e8 <__fp_szero>
    21e8:	5f 3f       	cpi	r21, 0xFF	; 255
    21ea:	ec f3       	brlt	.-6      	; 0x21e6 <__divsf3_pse+0x6a>
    21ec:	98 3e       	cpi	r25, 0xE8	; 232
    21ee:	dc f3       	brlt	.-10     	; 0x21e6 <__divsf3_pse+0x6a>
    21f0:	86 95       	lsr	r24
    21f2:	77 95       	ror	r23
    21f4:	67 95       	ror	r22
    21f6:	b7 95       	ror	r27
    21f8:	f7 95       	ror	r31
    21fa:	9f 5f       	subi	r25, 0xFF	; 255
    21fc:	c9 f7       	brne	.-14     	; 0x21f0 <__divsf3_pse+0x74>
    21fe:	88 0f       	add	r24, r24
    2200:	91 1d       	adc	r25, r1
    2202:	96 95       	lsr	r25
    2204:	87 95       	ror	r24
    2206:	97 f9       	bld	r25, 7
    2208:	08 95       	ret
    220a:	e1 e0       	ldi	r30, 0x01	; 1
    220c:	66 0f       	add	r22, r22
    220e:	77 1f       	adc	r23, r23
    2210:	88 1f       	adc	r24, r24
    2212:	bb 1f       	adc	r27, r27
    2214:	62 17       	cp	r22, r18
    2216:	73 07       	cpc	r23, r19
    2218:	84 07       	cpc	r24, r20
    221a:	ba 07       	cpc	r27, r26
    221c:	20 f0       	brcs	.+8      	; 0x2226 <__stack+0x27>
    221e:	62 1b       	sub	r22, r18
    2220:	73 0b       	sbc	r23, r19
    2222:	84 0b       	sbc	r24, r20
    2224:	ba 0b       	sbc	r27, r26
    2226:	ee 1f       	adc	r30, r30
    2228:	88 f7       	brcc	.-30     	; 0x220c <__stack+0xd>
    222a:	e0 95       	com	r30
    222c:	08 95       	ret

0000222e <__fixsfsi>:
    222e:	04 d0       	rcall	.+8      	; 0x2238 <__fixunssfsi>
    2230:	68 94       	set
    2232:	b1 11       	cpse	r27, r1
    2234:	d9 c0       	rjmp	.+434    	; 0x23e8 <__fp_szero>
    2236:	08 95       	ret

00002238 <__fixunssfsi>:
    2238:	bc d0       	rcall	.+376    	; 0x23b2 <__fp_splitA>
    223a:	88 f0       	brcs	.+34     	; 0x225e <__fixunssfsi+0x26>
    223c:	9f 57       	subi	r25, 0x7F	; 127
    223e:	90 f0       	brcs	.+36     	; 0x2264 <__fixunssfsi+0x2c>
    2240:	b9 2f       	mov	r27, r25
    2242:	99 27       	eor	r25, r25
    2244:	b7 51       	subi	r27, 0x17	; 23
    2246:	a0 f0       	brcs	.+40     	; 0x2270 <__fixunssfsi+0x38>
    2248:	d1 f0       	breq	.+52     	; 0x227e <__fixunssfsi+0x46>
    224a:	66 0f       	add	r22, r22
    224c:	77 1f       	adc	r23, r23
    224e:	88 1f       	adc	r24, r24
    2250:	99 1f       	adc	r25, r25
    2252:	1a f0       	brmi	.+6      	; 0x225a <__fixunssfsi+0x22>
    2254:	ba 95       	dec	r27
    2256:	c9 f7       	brne	.-14     	; 0x224a <__fixunssfsi+0x12>
    2258:	12 c0       	rjmp	.+36     	; 0x227e <__fixunssfsi+0x46>
    225a:	b1 30       	cpi	r27, 0x01	; 1
    225c:	81 f0       	breq	.+32     	; 0x227e <__fixunssfsi+0x46>
    225e:	c3 d0       	rcall	.+390    	; 0x23e6 <__fp_zero>
    2260:	b1 e0       	ldi	r27, 0x01	; 1
    2262:	08 95       	ret
    2264:	c0 c0       	rjmp	.+384    	; 0x23e6 <__fp_zero>
    2266:	67 2f       	mov	r22, r23
    2268:	78 2f       	mov	r23, r24
    226a:	88 27       	eor	r24, r24
    226c:	b8 5f       	subi	r27, 0xF8	; 248
    226e:	39 f0       	breq	.+14     	; 0x227e <__fixunssfsi+0x46>
    2270:	b9 3f       	cpi	r27, 0xF9	; 249
    2272:	cc f3       	brlt	.-14     	; 0x2266 <__fixunssfsi+0x2e>
    2274:	86 95       	lsr	r24
    2276:	77 95       	ror	r23
    2278:	67 95       	ror	r22
    227a:	b3 95       	inc	r27
    227c:	d9 f7       	brne	.-10     	; 0x2274 <__fixunssfsi+0x3c>
    227e:	3e f4       	brtc	.+14     	; 0x228e <__fixunssfsi+0x56>
    2280:	90 95       	com	r25
    2282:	80 95       	com	r24
    2284:	70 95       	com	r23
    2286:	61 95       	neg	r22
    2288:	7f 4f       	sbci	r23, 0xFF	; 255
    228a:	8f 4f       	sbci	r24, 0xFF	; 255
    228c:	9f 4f       	sbci	r25, 0xFF	; 255
    228e:	08 95       	ret

00002290 <__floatunsisf>:
    2290:	e8 94       	clt
    2292:	09 c0       	rjmp	.+18     	; 0x22a6 <__floatsisf+0x12>

00002294 <__floatsisf>:
    2294:	97 fb       	bst	r25, 7
    2296:	3e f4       	brtc	.+14     	; 0x22a6 <__floatsisf+0x12>
    2298:	90 95       	com	r25
    229a:	80 95       	com	r24
    229c:	70 95       	com	r23
    229e:	61 95       	neg	r22
    22a0:	7f 4f       	sbci	r23, 0xFF	; 255
    22a2:	8f 4f       	sbci	r24, 0xFF	; 255
    22a4:	9f 4f       	sbci	r25, 0xFF	; 255
    22a6:	99 23       	and	r25, r25
    22a8:	a9 f0       	breq	.+42     	; 0x22d4 <__floatsisf+0x40>
    22aa:	f9 2f       	mov	r31, r25
    22ac:	96 e9       	ldi	r25, 0x96	; 150
    22ae:	bb 27       	eor	r27, r27
    22b0:	93 95       	inc	r25
    22b2:	f6 95       	lsr	r31
    22b4:	87 95       	ror	r24
    22b6:	77 95       	ror	r23
    22b8:	67 95       	ror	r22
    22ba:	b7 95       	ror	r27
    22bc:	f1 11       	cpse	r31, r1
    22be:	f8 cf       	rjmp	.-16     	; 0x22b0 <__floatsisf+0x1c>
    22c0:	fa f4       	brpl	.+62     	; 0x2300 <__floatsisf+0x6c>
    22c2:	bb 0f       	add	r27, r27
    22c4:	11 f4       	brne	.+4      	; 0x22ca <__floatsisf+0x36>
    22c6:	60 ff       	sbrs	r22, 0
    22c8:	1b c0       	rjmp	.+54     	; 0x2300 <__floatsisf+0x6c>
    22ca:	6f 5f       	subi	r22, 0xFF	; 255
    22cc:	7f 4f       	sbci	r23, 0xFF	; 255
    22ce:	8f 4f       	sbci	r24, 0xFF	; 255
    22d0:	9f 4f       	sbci	r25, 0xFF	; 255
    22d2:	16 c0       	rjmp	.+44     	; 0x2300 <__floatsisf+0x6c>
    22d4:	88 23       	and	r24, r24
    22d6:	11 f0       	breq	.+4      	; 0x22dc <__floatsisf+0x48>
    22d8:	96 e9       	ldi	r25, 0x96	; 150
    22da:	11 c0       	rjmp	.+34     	; 0x22fe <__floatsisf+0x6a>
    22dc:	77 23       	and	r23, r23
    22de:	21 f0       	breq	.+8      	; 0x22e8 <__floatsisf+0x54>
    22e0:	9e e8       	ldi	r25, 0x8E	; 142
    22e2:	87 2f       	mov	r24, r23
    22e4:	76 2f       	mov	r23, r22
    22e6:	05 c0       	rjmp	.+10     	; 0x22f2 <__floatsisf+0x5e>
    22e8:	66 23       	and	r22, r22
    22ea:	71 f0       	breq	.+28     	; 0x2308 <__floatsisf+0x74>
    22ec:	96 e8       	ldi	r25, 0x86	; 134
    22ee:	86 2f       	mov	r24, r22
    22f0:	70 e0       	ldi	r23, 0x00	; 0
    22f2:	60 e0       	ldi	r22, 0x00	; 0
    22f4:	2a f0       	brmi	.+10     	; 0x2300 <__floatsisf+0x6c>
    22f6:	9a 95       	dec	r25
    22f8:	66 0f       	add	r22, r22
    22fa:	77 1f       	adc	r23, r23
    22fc:	88 1f       	adc	r24, r24
    22fe:	da f7       	brpl	.-10     	; 0x22f6 <__floatsisf+0x62>
    2300:	88 0f       	add	r24, r24
    2302:	96 95       	lsr	r25
    2304:	87 95       	ror	r24
    2306:	97 f9       	bld	r25, 7
    2308:	08 95       	ret

0000230a <__fp_cmp>:
    230a:	99 0f       	add	r25, r25
    230c:	00 08       	sbc	r0, r0
    230e:	55 0f       	add	r21, r21
    2310:	aa 0b       	sbc	r26, r26
    2312:	e0 e8       	ldi	r30, 0x80	; 128
    2314:	fe ef       	ldi	r31, 0xFE	; 254
    2316:	16 16       	cp	r1, r22
    2318:	17 06       	cpc	r1, r23
    231a:	e8 07       	cpc	r30, r24
    231c:	f9 07       	cpc	r31, r25
    231e:	c0 f0       	brcs	.+48     	; 0x2350 <__fp_cmp+0x46>
    2320:	12 16       	cp	r1, r18
    2322:	13 06       	cpc	r1, r19
    2324:	e4 07       	cpc	r30, r20
    2326:	f5 07       	cpc	r31, r21
    2328:	98 f0       	brcs	.+38     	; 0x2350 <__fp_cmp+0x46>
    232a:	62 1b       	sub	r22, r18
    232c:	73 0b       	sbc	r23, r19
    232e:	84 0b       	sbc	r24, r20
    2330:	95 0b       	sbc	r25, r21
    2332:	39 f4       	brne	.+14     	; 0x2342 <__fp_cmp+0x38>
    2334:	0a 26       	eor	r0, r26
    2336:	61 f0       	breq	.+24     	; 0x2350 <__fp_cmp+0x46>
    2338:	23 2b       	or	r18, r19
    233a:	24 2b       	or	r18, r20
    233c:	25 2b       	or	r18, r21
    233e:	21 f4       	brne	.+8      	; 0x2348 <__fp_cmp+0x3e>
    2340:	08 95       	ret
    2342:	0a 26       	eor	r0, r26
    2344:	09 f4       	brne	.+2      	; 0x2348 <__fp_cmp+0x3e>
    2346:	a1 40       	sbci	r26, 0x01	; 1
    2348:	a6 95       	lsr	r26
    234a:	8f ef       	ldi	r24, 0xFF	; 255
    234c:	81 1d       	adc	r24, r1
    234e:	81 1d       	adc	r24, r1
    2350:	08 95       	ret

00002352 <__fp_inf>:
    2352:	97 f9       	bld	r25, 7
    2354:	9f 67       	ori	r25, 0x7F	; 127
    2356:	80 e8       	ldi	r24, 0x80	; 128
    2358:	70 e0       	ldi	r23, 0x00	; 0
    235a:	60 e0       	ldi	r22, 0x00	; 0
    235c:	08 95       	ret

0000235e <__fp_nan>:
    235e:	9f ef       	ldi	r25, 0xFF	; 255
    2360:	80 ec       	ldi	r24, 0xC0	; 192
    2362:	08 95       	ret

00002364 <__fp_pscA>:
    2364:	00 24       	eor	r0, r0
    2366:	0a 94       	dec	r0
    2368:	16 16       	cp	r1, r22
    236a:	17 06       	cpc	r1, r23
    236c:	18 06       	cpc	r1, r24
    236e:	09 06       	cpc	r0, r25
    2370:	08 95       	ret

00002372 <__fp_pscB>:
    2372:	00 24       	eor	r0, r0
    2374:	0a 94       	dec	r0
    2376:	12 16       	cp	r1, r18
    2378:	13 06       	cpc	r1, r19
    237a:	14 06       	cpc	r1, r20
    237c:	05 06       	cpc	r0, r21
    237e:	08 95       	ret

00002380 <__fp_round>:
    2380:	09 2e       	mov	r0, r25
    2382:	03 94       	inc	r0
    2384:	00 0c       	add	r0, r0
    2386:	11 f4       	brne	.+4      	; 0x238c <__fp_round+0xc>
    2388:	88 23       	and	r24, r24
    238a:	52 f0       	brmi	.+20     	; 0x23a0 <__fp_round+0x20>
    238c:	bb 0f       	add	r27, r27
    238e:	40 f4       	brcc	.+16     	; 0x23a0 <__fp_round+0x20>
    2390:	bf 2b       	or	r27, r31
    2392:	11 f4       	brne	.+4      	; 0x2398 <__fp_round+0x18>
    2394:	60 ff       	sbrs	r22, 0
    2396:	04 c0       	rjmp	.+8      	; 0x23a0 <__fp_round+0x20>
    2398:	6f 5f       	subi	r22, 0xFF	; 255
    239a:	7f 4f       	sbci	r23, 0xFF	; 255
    239c:	8f 4f       	sbci	r24, 0xFF	; 255
    239e:	9f 4f       	sbci	r25, 0xFF	; 255
    23a0:	08 95       	ret

000023a2 <__fp_split3>:
    23a2:	57 fd       	sbrc	r21, 7
    23a4:	90 58       	subi	r25, 0x80	; 128
    23a6:	44 0f       	add	r20, r20
    23a8:	55 1f       	adc	r21, r21
    23aa:	59 f0       	breq	.+22     	; 0x23c2 <__fp_splitA+0x10>
    23ac:	5f 3f       	cpi	r21, 0xFF	; 255
    23ae:	71 f0       	breq	.+28     	; 0x23cc <__fp_splitA+0x1a>
    23b0:	47 95       	ror	r20

000023b2 <__fp_splitA>:
    23b2:	88 0f       	add	r24, r24
    23b4:	97 fb       	bst	r25, 7
    23b6:	99 1f       	adc	r25, r25
    23b8:	61 f0       	breq	.+24     	; 0x23d2 <__fp_splitA+0x20>
    23ba:	9f 3f       	cpi	r25, 0xFF	; 255
    23bc:	79 f0       	breq	.+30     	; 0x23dc <__fp_splitA+0x2a>
    23be:	87 95       	ror	r24
    23c0:	08 95       	ret
    23c2:	12 16       	cp	r1, r18
    23c4:	13 06       	cpc	r1, r19
    23c6:	14 06       	cpc	r1, r20
    23c8:	55 1f       	adc	r21, r21
    23ca:	f2 cf       	rjmp	.-28     	; 0x23b0 <__fp_split3+0xe>
    23cc:	46 95       	lsr	r20
    23ce:	f1 df       	rcall	.-30     	; 0x23b2 <__fp_splitA>
    23d0:	08 c0       	rjmp	.+16     	; 0x23e2 <__fp_splitA+0x30>
    23d2:	16 16       	cp	r1, r22
    23d4:	17 06       	cpc	r1, r23
    23d6:	18 06       	cpc	r1, r24
    23d8:	99 1f       	adc	r25, r25
    23da:	f1 cf       	rjmp	.-30     	; 0x23be <__fp_splitA+0xc>
    23dc:	86 95       	lsr	r24
    23de:	71 05       	cpc	r23, r1
    23e0:	61 05       	cpc	r22, r1
    23e2:	08 94       	sec
    23e4:	08 95       	ret

000023e6 <__fp_zero>:
    23e6:	e8 94       	clt

000023e8 <__fp_szero>:
    23e8:	bb 27       	eor	r27, r27
    23ea:	66 27       	eor	r22, r22
    23ec:	77 27       	eor	r23, r23
    23ee:	cb 01       	movw	r24, r22
    23f0:	97 f9       	bld	r25, 7
    23f2:	08 95       	ret

000023f4 <__mulsf3>:
    23f4:	0b d0       	rcall	.+22     	; 0x240c <__mulsf3x>
    23f6:	c4 cf       	rjmp	.-120    	; 0x2380 <__fp_round>
    23f8:	b5 df       	rcall	.-150    	; 0x2364 <__fp_pscA>
    23fa:	28 f0       	brcs	.+10     	; 0x2406 <__mulsf3+0x12>
    23fc:	ba df       	rcall	.-140    	; 0x2372 <__fp_pscB>
    23fe:	18 f0       	brcs	.+6      	; 0x2406 <__mulsf3+0x12>
    2400:	95 23       	and	r25, r21
    2402:	09 f0       	breq	.+2      	; 0x2406 <__mulsf3+0x12>
    2404:	a6 cf       	rjmp	.-180    	; 0x2352 <__fp_inf>
    2406:	ab cf       	rjmp	.-170    	; 0x235e <__fp_nan>
    2408:	11 24       	eor	r1, r1
    240a:	ee cf       	rjmp	.-36     	; 0x23e8 <__fp_szero>

0000240c <__mulsf3x>:
    240c:	ca df       	rcall	.-108    	; 0x23a2 <__fp_split3>
    240e:	a0 f3       	brcs	.-24     	; 0x23f8 <__mulsf3+0x4>

00002410 <__mulsf3_pse>:
    2410:	95 9f       	mul	r25, r21
    2412:	d1 f3       	breq	.-12     	; 0x2408 <__mulsf3+0x14>
    2414:	95 0f       	add	r25, r21
    2416:	50 e0       	ldi	r21, 0x00	; 0
    2418:	55 1f       	adc	r21, r21
    241a:	62 9f       	mul	r22, r18
    241c:	f0 01       	movw	r30, r0
    241e:	72 9f       	mul	r23, r18
    2420:	bb 27       	eor	r27, r27
    2422:	f0 0d       	add	r31, r0
    2424:	b1 1d       	adc	r27, r1
    2426:	63 9f       	mul	r22, r19
    2428:	aa 27       	eor	r26, r26
    242a:	f0 0d       	add	r31, r0
    242c:	b1 1d       	adc	r27, r1
    242e:	aa 1f       	adc	r26, r26
    2430:	64 9f       	mul	r22, r20
    2432:	66 27       	eor	r22, r22
    2434:	b0 0d       	add	r27, r0
    2436:	a1 1d       	adc	r26, r1
    2438:	66 1f       	adc	r22, r22
    243a:	82 9f       	mul	r24, r18
    243c:	22 27       	eor	r18, r18
    243e:	b0 0d       	add	r27, r0
    2440:	a1 1d       	adc	r26, r1
    2442:	62 1f       	adc	r22, r18
    2444:	73 9f       	mul	r23, r19
    2446:	b0 0d       	add	r27, r0
    2448:	a1 1d       	adc	r26, r1
    244a:	62 1f       	adc	r22, r18
    244c:	83 9f       	mul	r24, r19
    244e:	a0 0d       	add	r26, r0
    2450:	61 1d       	adc	r22, r1
    2452:	22 1f       	adc	r18, r18
    2454:	74 9f       	mul	r23, r20
    2456:	33 27       	eor	r19, r19
    2458:	a0 0d       	add	r26, r0
    245a:	61 1d       	adc	r22, r1
    245c:	23 1f       	adc	r18, r19
    245e:	84 9f       	mul	r24, r20
    2460:	60 0d       	add	r22, r0
    2462:	21 1d       	adc	r18, r1
    2464:	82 2f       	mov	r24, r18
    2466:	76 2f       	mov	r23, r22
    2468:	6a 2f       	mov	r22, r26
    246a:	11 24       	eor	r1, r1
    246c:	9f 57       	subi	r25, 0x7F	; 127
    246e:	50 40       	sbci	r21, 0x00	; 0
    2470:	8a f0       	brmi	.+34     	; 0x2494 <__mulsf3_pse+0x84>
    2472:	e1 f0       	breq	.+56     	; 0x24ac <__mulsf3_pse+0x9c>
    2474:	88 23       	and	r24, r24
    2476:	4a f0       	brmi	.+18     	; 0x248a <__mulsf3_pse+0x7a>
    2478:	ee 0f       	add	r30, r30
    247a:	ff 1f       	adc	r31, r31
    247c:	bb 1f       	adc	r27, r27
    247e:	66 1f       	adc	r22, r22
    2480:	77 1f       	adc	r23, r23
    2482:	88 1f       	adc	r24, r24
    2484:	91 50       	subi	r25, 0x01	; 1
    2486:	50 40       	sbci	r21, 0x00	; 0
    2488:	a9 f7       	brne	.-22     	; 0x2474 <__mulsf3_pse+0x64>
    248a:	9e 3f       	cpi	r25, 0xFE	; 254
    248c:	51 05       	cpc	r21, r1
    248e:	70 f0       	brcs	.+28     	; 0x24ac <__mulsf3_pse+0x9c>
    2490:	60 cf       	rjmp	.-320    	; 0x2352 <__fp_inf>
    2492:	aa cf       	rjmp	.-172    	; 0x23e8 <__fp_szero>
    2494:	5f 3f       	cpi	r21, 0xFF	; 255
    2496:	ec f3       	brlt	.-6      	; 0x2492 <__mulsf3_pse+0x82>
    2498:	98 3e       	cpi	r25, 0xE8	; 232
    249a:	dc f3       	brlt	.-10     	; 0x2492 <__mulsf3_pse+0x82>
    249c:	86 95       	lsr	r24
    249e:	77 95       	ror	r23
    24a0:	67 95       	ror	r22
    24a2:	b7 95       	ror	r27
    24a4:	f7 95       	ror	r31
    24a6:	e7 95       	ror	r30
    24a8:	9f 5f       	subi	r25, 0xFF	; 255
    24aa:	c1 f7       	brne	.-16     	; 0x249c <__mulsf3_pse+0x8c>
    24ac:	fe 2b       	or	r31, r30
    24ae:	88 0f       	add	r24, r24
    24b0:	91 1d       	adc	r25, r1
    24b2:	96 95       	lsr	r25
    24b4:	87 95       	ror	r24
    24b6:	97 f9       	bld	r25, 7
    24b8:	08 95       	ret

000024ba <__udivmodhi4>:
    24ba:	aa 1b       	sub	r26, r26
    24bc:	bb 1b       	sub	r27, r27
    24be:	51 e1       	ldi	r21, 0x11	; 17
    24c0:	07 c0       	rjmp	.+14     	; 0x24d0 <__udivmodhi4_ep>

000024c2 <__udivmodhi4_loop>:
    24c2:	aa 1f       	adc	r26, r26
    24c4:	bb 1f       	adc	r27, r27
    24c6:	a6 17       	cp	r26, r22
    24c8:	b7 07       	cpc	r27, r23
    24ca:	10 f0       	brcs	.+4      	; 0x24d0 <__udivmodhi4_ep>
    24cc:	a6 1b       	sub	r26, r22
    24ce:	b7 0b       	sbc	r27, r23

000024d0 <__udivmodhi4_ep>:
    24d0:	88 1f       	adc	r24, r24
    24d2:	99 1f       	adc	r25, r25
    24d4:	5a 95       	dec	r21
    24d6:	a9 f7       	brne	.-22     	; 0x24c2 <__udivmodhi4_loop>
    24d8:	80 95       	com	r24
    24da:	90 95       	com	r25
    24dc:	bc 01       	movw	r22, r24
    24de:	cd 01       	movw	r24, r26
    24e0:	08 95       	ret

000024e2 <_exit>:
    24e2:	f8 94       	cli

000024e4 <__stop_program>:
    24e4:	ff cf       	rjmp	.-2      	; 0x24e4 <__stop_program>
